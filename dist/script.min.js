/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */


	var seed = Math.floor(Math.random() * 10000.0);

	var module = noise = {};
  
	function Grad(x, y, z) {
	  this.x = x; this.y = y; this.z = z;
	}
	
	Grad.prototype.dot2 = function(x, y) {
	  return this.x*x + this.y*y;
	};
  
	Grad.prototype.dot3 = function(x, y, z) {
	  return this.x*x + this.y*y + this.z*z;
	};
  
	var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
				 new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
				 new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];
	
	var p = new Array(256);
	for(var i = 0; i < 256; i++)
	{
		p[i] = rrg(0, 255);
	}
	
	// To remove the need for index wrapping, double the permutation table length
	var perm = new Array(512);
	var gradP = new Array(512);

  
	// This isn't a very good seeding function, but it works ok. It supports 2^16
	// different seed values. Write something better if you need more seeds.
	module.seed = function(seed) {
	  if(seed > 0 && seed < 1) {
		// Scale the seed out
		seed *= 65536;
	  }
  
	  seed = Math.floor(seed);
	  if(seed < 256) {
		seed |= seed << 8;
	  }
  
	  for(var i = 0; i < 256; i++) {
		var v;
		if (i & 1) {
		  v = p[i] ^ (seed & 255);
		} else {
		  v = p[i] ^ ((seed>>8) & 255);
		}
  
		perm[i] = perm[i + 256] = v;
		gradP[i] = gradP[i + 256] = grad3[v % 12];
	  }
	};
  
	module.seed(0);
	// ##### Perlin noise stuff
  
	function fade(t) {
	  return t*t*t*(t*(t*6-15)+10);
	}
  
	function lerp(a, b, t) {
	  return (1-t)*a + t*b;
	}
  
	// 2D Perlin Noise
	module.perlin2 = function(x, y) {
	  // Find unit grid cell containing point
	  var X = Math.floor(x), Y = Math.floor(y);
	  // Get relative xy coordinates of point within that cell
	  x = x - X; y = y - Y;
	  // Wrap the integer cells at 255 (smaller integer period can be introduced here)
	  X = X & 255; Y = Y & 255;
  
	  // Calculate noise contributions from each of the four corners
	  var n00 = gradP[X+perm[Y]].dot2(x, y);
	  var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
	  var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
	  var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);
  
	  // Compute the fade curve value for x
	  var u = fade(x);
  
	  // Interpolate the four results
	  return lerp(
		  lerp(n00, n10, u),
		  lerp(n01, n11, u),
		 fade(y));
	};
  
	noise.seed(seed);
let letters = {
	'A': [
		[1, 1, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1, 1],
		[1,0, 1]
	],
	'B': [
		[1, 1],
		[1,0, 1],
		[1, 1, 1],
		[1,0, 1],
		[1, 1]
	],
	'C': [
		[1, 1, 1],
		[1],
		[1],
		[1],
		[1, 1, 1]
	],
	'D': [
		[1, 1],
		[1,0, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1]
	],
	'E': [
		[1, 1, 1],
		[1],
		[1, 1, 1],
		[1],
		[1, 1, 1]
	],
	'F': [
		[1, 1, 1],
		[1],
		[1, 1],
		[1],
		[1]
	],
	'G': [
		[, 1, 1],
		[1],
		[1,0, 1, 1],
		[1,0,0, 1],
		[, 1, 1]
	],
	'H': [
		[1,0, 1],
		[1,0, 1],
		[1, 1, 1],
		[1,0, 1],
		[1,0, 1]
	],
	'I': [
		[1, 1, 1],
		[, 1],
		[, 1],
		[, 1],
		[1, 1, 1]
	],
	'J': [
		[1, 1, 1],
		[,0, 1],
		[,0, 1],
		[1,0, 1],
		[1, 1, 1]
	],
	'K': [
		[1,0,0, 1],
		[1,0, 1],
		[1, 1],
		[1,0, 1],
		[1,0,0, 1]
	],
	'L': [
		[1],
		[1],
		[1],
		[1],
		[1, 1, 1]
	],
	'M': [
		[1, 1, 1, 1, 1],
		[1,0, 1,0, 1],
		[1,0, 1,0, 1],
		[1,0,0,0, 1],
		[1,0,0,0, 1]
	],
	'N': [
		[1,0,0, 1],
		[1, 1,0, 1],
		[1,0, 1, 1],
		[1,0,0, 1],
		[1,0,0, 1]
	],
	'O': [
		[1, 1, 1],
		[1,0, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1, 1]
	],
	'P': [
		[1, 1, 1],
		[1,0, 1],
		[1, 1, 1],
		[1],
		[1]
	],
	'Q': [
		[0, 1, 1],
		[1,0,0, 1],
		[1,0,0, 1],
		[1,0, 1, 1],
		[1, 1, 1, 1]
	],
	'R': [
		[1, 1, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1],
		[1,0, 1]
	],
	'S': [
		[1, 1, 1],
		[1],
		[1, 1, 1],
		[,0, 1],
		[1, 1, 1]
	],
	'T': [
		[1, 1, 1],
		[, 1],
		[, 1],
		[, 1],
		[, 1]
	],
	'U': [
		[1,0, 1],
		[1,0, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1, 1]
	],
	'V': [
		[1,0,0,0, 1],
		[1,0,0,0, 1],
		[, 1,0, 1],
		[, 1,0, 1],
		[,0, 1]
	],
	'W': [
		[1,0,0,0, 1],
		[1,0,0,0, 1],
		[1,0,0,0, 1],
		[1,0, 1,0, 1],
		[1, 1, 1, 1, 1]
	],
	'X': [
		[1,0,0,0, 1],
		[, 1,0, 1],
		[,0, 1],
		[, 1,0, 1],
		[1,0,0,0, 1]
	],
	'Y': [
		[1,0, 1],
		[1,0, 1],
		[, 1],
		[, 1],
		[, 1]
	],
	'Z': [
		[1, 1, 1, 1, 1],
		[,0,0, 1],
		[,0, 1],
		[, 1],
		[1, 1, 1, 1, 1]
	],
	'0': [
		[1, 1, 1],
		[1,0, 1],
		[1,0, 1],
		[1,0, 1],
		[1, 1, 1]
	],
	'1': [
		[, 1],
		[, 1],
		[, 1],
		[, 1],
		[, 1]
	],
	'2': [
		[1,1,1],
		[0,0,1],
		[1,1,1],
		[1,0,0],
		[1,1,1]
	],
	'3':[
		[1,1,1],
		[0,0,1],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	'4':[
		[1,0,1],
		[1,0,1],
		[1,1,1],
		[0,0,1],
		[0,0,1]
	],
	'5':[
		[1,1,1],
		[1,0,0],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	'6':[
		[1,1,1],
		[1,0,0],
		[1,1,1],
		[1,0,1],
		[1,1,1]
	],
	'7':[
		[1,1,1],
		[0,0,1],
		[0,0,1],
		[0,0,1],
		[0,0,1]
	],
	'8':[
		[1,1,1],
		[1,0,1],
		[1,1,1],
		[1,0,1],
		[1,1,1]
	],
	'9':[
		[1,1,1],
		[1,0,1],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	':':[
		[,,],
		[,1,],
		[,,],
		[,1,],
		[,,]
	],
	'/':[
		[0,0,1],
		[0,1,0],
		[0,1,0],
		[0,1,0],
		[1,0,0]
	],
	' ': [
		[,0,],
		[,0,],
		[,0,],
		[,0,],
		[,0,]
	],
	'%':[
		[0,0,0,1,0],
		[1,0,1,0,0],
		[0,0,1,0,0],
		[0,0,1,0,1],
		[0,1,0,0,0]
	],
	',': [
		[,,],
		[,,],
		[,,],
		[,1,],
		[1,,]
	],
};

function getNeededText(str)
{
	
	var needed = [];
	str = str.toUpperCase();
	for (var i = 0; i < str.length; i++) 
	{
		var letter = letters[str.charAt(i)];
		if (letter != undefined) 
		{
			needed.push(letter);
		}
	}


	return needed;
}

function getTextSize(string, size)
{
	var needed = getNeededText(string);
	var xoff = 0;

	for(let i = 0; i < needed.length; i++)
	{
		var char = needed[i];
		var addx = 0;

		for(let j = 0; j < char.length; j++)
		{
			var row = char[j];
			addx = Math.max(addx, row.length * size);
		}

		xoff += size + addx;
	}

	return xoff;
}

function drawText(string, x, y, size, color)
{
	var needed = getNeededText(string);
	ctx.fillStyle = color;

	var xoff = 0;

	for(let i = 0; i < needed.length; i++)
	{
		var char = needed[i];
		var yoff = 0;
		var addx = 0;

		for(let j = 0; j < char.length; j++)
		{
			var row = char[j];
			for(let subx = 0; subx < row.length; subx++)
			{
				if(row[subx])
				{
					ctx.fillRect(subx * size + xoff + x, yoff + y, size, size);
				}
			}

			addx = Math.max(addx, row.length * size);
			yoff += size;
		}

		xoff += size + addx;
	}

	return xoff;
}


function srandom() {
    var x = Math.sin(seed++) * 10000;
    return x - Math.floor(x);
}

function planetAtTime(planetid, gtime)
{
	var planet = planets[planetid];

	if(planetid == 0)
	{
		return {x: 0.0, y: 0.0};
	}

	if(planet.center == 0)
	{
		return orbit(0, 0, planets[planet.center].mass, planet.mass, planet.orbitRadius, gtime + planet.orbitOffset);
	}
	else 
	{
		var child = planetAtTime(planet.center, gtime);
		return orbit(child.x, child.y, planets[planet.center].mass, planet.mass, planet.orbitRadius, gtime + planet.orbitOffset);
	}
}

function orbit(cx, cy, cmass, omass, radius, gtime)
{
	var speed = orbitSpeed(cmass, omass, radius) / radius;

	return {x: Math.cos(gtime * speed) * radius + cx, y: Math.sin(gtime * speed) * radius + cy};
}

function orbitSpeed(cmass, omass, radius)
{
	var grav = G() * (cmass + omass);
	var speed = Math.sqrt(grav / radius);

	return speed;
}

function orbitVelocityLow(cx, cy, cmass, omass, radius, ntime)
{
	var a = orbit(cx, cy, cmass, omass, radius, ntime);
	var b = orbit(cx, cy, cmass, omass, radius, ntime + 0.01);
	var sumX = b.x - a.x; 
	var sumY = b.y - a.y;
	var out = normalize(sumX, sumY);
	var speed = orbitSpeed(cmass, omass, radius);
	out.x *= speed;
	out.y *= speed;

	return out;
}

// Gets accumulated orbit velocity
function orbitVelocity(id, omass, radius, time, offset)
{
	if(id == 0)
	{
		if(radius == 0.0)
		{

			return {x: 0.0, y: 0.0};
		}
		else
		{
			return orbitVelocityLow(0, 0, planets[0].mass, omass, radius, time + offset);
		}
	}
	else
	{
		var planet = planets[id];
		var cx = planets[planet.center].x;
		var cy = planets[planet.center].y;
		var cmass = planets[planet.center].mass;

		var ourVel = orbitVelocityLow(cx, cy, cmass, planet.mass, planet.orbitRadius, time + planet.orbitOffset);
		var childVel = orbitVelocity(planet.center, omass, 0.0, time, offset);

		var sum0 = {x: ourVel.x + childVel.x, y: ourVel.y + childVel.y};


		if(radius == 0.0)
		{
			return sum0;
		}
		else
		{
			var topVel = orbitVelocityLow(planet.x, planet.y, planet.mass, omass, radius, time + offset);
			var sum1 = {x: sum0.x + topVel.x, y: sum0.y + topVel.y}
			return sum1;
		}
	}
}

// Computes gravity from all attractors
function gravity(point, ntime)
{
	var forceTotal = {x: 0.0, y: 0.0};

	if(ntime === -1.0)
	{
		for(var i = 0; i < planets.length; i++)
		{
			var pos = planets[i];
			var force = gravityFrom(point, pos.x, pos.y, planets[i].mass);
			forceTotal.x += force.x;
			forceTotal.y += force.y;
		}
	}
	else 
	{
		for(var i = 0; i < planets.length; i++)
		{
			var pos = planetAtTime(i, ntime);
			var force = gravityFrom(point, pos.x, pos.y, planets[i].mass);
			forceTotal.x += force.x;
			forceTotal.y += force.y;
		}
	}

	return forceTotal;
}

function collidesWithPlanet(point, ntime)
{
	for(var i = 0; i < planets.length; i++)
	{
		var pos = planetAtTime(i, ntime);
		var dist = distance(point.x, point.y, pos.x, pos.y);
		if(dist <= planets[i].radius * 1.02)
		{
			var diff = {x: point.x - pos.x, y: point.y - pos.y}
			var diffNrm = normalize(diff.x, diff.y);
			var x = diffNrm.x * planets[i].radius * 1.02;
			var y = diffNrm.y * planets[i].radius * 1.02;
			var xn = diffNrm.x;
			var yn = diffNrm.y;

			return {planet: i, sx: x, sy: y, nx: xn, ny: yn};
		}
	}

	return null;
}


function collidesWithCity(point, ntime)
{
	var planetC = collidesWithPlanet(point, ntime);
	if(planetC != null)
	{
		var planet = planets[planetC.planet];
		if(planet.cities != undefined)
		{
			for(var i = 0; i < planet.cities.length; i++)
			{
				var city = planet.cities[i];
				var rx = city.x * planet.radius * 0.98 + planet.x;
				var ry = city.y * planet.radius * 0.98 + planet.y;
				if(distance(rx, ry, point.x, point.y) <= city.size * 2.0)
				{
					return {city: city, idx: i, planet: planetC.planet, rx: rx, ry: ry};
				}
			}
		}
	}

	return null;
}

function collidesWithShip(point, side = -1, extraRadius = 1.0)
{
	for(var i = 0; i < ships.length; i++)
	{
		if(isEnemy(ships[i].side, side) || side == -1)
		{
			var size = 5.0;
			if(ships[i].type == 1)
			{
				size = 14.0;
			}
			else if(ships[i].type == 2)
			{
				size = 28.0;
			}

			if(distance(point.x, point.y, ships[i].x, ships[i].y) <= size * extraRadius)
			{
				ships[i].idx = i;
				return ships[i];
			}
		}
	}

	return null;
}

function collidesWithAny(point, ntime, side = -1, extraRadius = 1.0)
{
	var city = collidesWithCity(point, ntime);
	var planet = collidesWithPlanet(point, ntime);
	var ship = collidesWithShip(point, side, extraRadius);
	return {city: city, planet: planet, ship: ship};
}

function gravityFrom(point, cx, cy, cmass)
{
	var dist2 = distance2(point.x, point.y, cx, cy);
	var diff = normalize(cx - point.x, cy - point.y)
	var force = G() * (cmass / dist2);

	return {x: diff.x * force, y: diff.y * force};
}

function G()
{
	return 2.5;
}

function putShipInOrbit(ship, id, radius, offset, prograde)
{
	var pos = orbit(planets[id].x, planets[id].y, planets[id].mass, shipMass, radius, time + offset);
	var vel = orbitVelocity(id, shipMass, radius, time, offset);
	ship.x = pos.x; ship.y = pos.y;
	ship.speed.x = vel.x; ship.speed.y = vel.y;
	
}

// 5/10 -> Fighters
// 4/10 -> Freighters
// 1/10 -> Destroyer
function randomShip(side)
{
	var value = rrg(0, 100);
	var level = rrg(0, 5);

	if(value <= 50)
	{
		return createShip(0, srandom(), side, level);
	}
	else if(value <= 90)
	{
		return createShip(1, srandom(), side, level);
	}
	else 
	{
		return createShip(2, srandom(), side, level);
	}
}


function randomColor(type, mult)
{
	var r, g, b;

	if(type == 0)
	{
		// Rocky
		var val = rrg(128, 180);
		r = val; g = val; b = val;
	}
	else if(type == 1)
	{
		// Terra ground
		if(rrg(0, 100) >= 50)
		{
			// Grassy 
			r = rrg(50, 170);
			g = rrg(90, 200);
		 	b = rrg(80, 170);
		}
		else
		{
			// Muddy
			r =  rrg(100, 200);
			g = rrg(80, 170);
			b = rrg(50, 100);	
		}

	}
	else if(type == 2)
	{
		// Desert ground
		r = rrg(100, 250);
		g = rrg(40, 100);
		b = rrg(50, 100);
	}
	else if(type == 3)
	{
		// Gas planet
		r = rrg(50, 200);
		g = rrg(50, 200);
		b = rrg(50, 200);
	}
	else
	{
		r = rrg(0, 255);
		g = rrg(0, 255);
		b = rrg(0, 255);
	}

	return 'rgb(' + r * mult + ',' + g * mult + ',' + b * mult + ')';
}

function getPlanetSpeed(planet, time)
{
	if(planet == planets[0])
	{
		return {x: 0.0, y: 0.0};
	}
	else
	{
		return orbitVelocity(planet.center, planet.mass, planet.orbitRadius, time, planet.orbitOffset);
	}
}

function showEvent(str, time)
{
	eventStr = str
	eventTimer = time;
}

// 2 = player side
function sideColor(side)
{
	var r, g, b;

	if(side == 0)
	{
		// Human ships, blueish grey
		r = rrg(80, 160);
		g = r * rrg(80, 100) * 0.01;
		b = r * rrg(100, 130) * 0.01;
	}
	else if(side == 1)
	{
		// Soft reds
		r = rrg(120, 210);
		g = r * rrg(40, 90) * 0.01;
		b = r * rrg(20, 50) * 0.01;
	}
	else 
	{
		// Grey
		r = rrg(80, 110);
		g = r;
		b = r;
	}

	return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function makeColorAlpha(color)
{
	var colorCopy = color;
	colorCopy = colorCopy.splice(0, 4, "");
	colorCopy = colorCopy.splice(color.length - 5, 2, "");
	return colorCopy;
}

function rrg(min, max) 
{
	return Math.floor(min + srandom()*(max + 1 - min))
}

if (!String.prototype.splice) {
	String.prototype.splice = function(start, delCount, newSubStr) {
		return this.slice(0, start) + newSubStr + this.slice(start + Math.abs(delCount));
	};
}

function imageDataToImage(data)
{
	var tmpCanvas = document.createElement("canvas");
	var tmpctx = tmpCanvas.getContext("2d");
	tmpCanvas.width = data.width;
	tmpCanvas.height = data.height;
	tmpctx.putImageData(data, 0, 0);

	var image = new Image();
	image.src = tmpCanvas.toDataURL();

	tmpCanvas.innerHTML = "";

	return image;
}

function drawBright(x, y, size, alpha)
{
	var old = ctx.globalCompositeOperation;
	ctx.globalCompositeOperation = 'lighter';

	ctx.translate(x, y);
	ctx.scale(size, size);
	ctx.drawImage(brightImage, -brightData.width / 2.0, -brightData.height / 2.0);
	ctx.scale(1.0 / size, 1.0 / size);
	ctx.translate(-x, -y);

	ctx.globalCompositeOperation = old;
}

function doCameraTransform()
{
	ctx.setTransform(1, 0, 0, 1, 0, 0);
	
	ctx.translate(canvas.width / 2.0, canvas.height / 2.0);

	if(lockCamera)
	{
		ctx.rotate(-ships[0].rot - Math.PI);
	}

	ctx.scale(camera.zoom, camera.zoom);
	ctx.translate(-camera.x, -camera.y);
}

function sanitizeAngle(angle)
{
	var a = angle;
	if(Math.abs(a) >= Math.PI * 2.0)
	{
		a = a % (Math.PI * 2.0);
	}

	if(a <= 0.0)
	{
		a = Math.PI * 2.0 + a;
	}

	return a;
}

function angleDiff(a, b)
{
	var diff = (a - b);

	if(diff > Math.PI)
	{
		diff = -2.0 * Math.PI + diff;
	}

	return diff;
}

function priceToString(price)
{
	if(price == 0)
	{
		return "Free";
	}
	else if(isNaN(price))
	{
		return "";
	}
	else 
	{
		return price.toString();
	}
}

function normalize(x1, y1)
{
	var length = Math.sqrt(x1 * x1 + y1 * y1);
	return {x: x1 / length, y: y1 / length};
}

function distance2(x1, y1, x2, y2)
{
	let xdiff = x1 - x2;
	let ydiff = y1 - y2;
	return xdiff * xdiff + ydiff * ydiff;
}

function distance(x1, y1, x2, y2)
{
	return Math.sqrt(distance2(x1, y1, x2, y2));
}

function rotate(x, y, angle)
{
	var polar = Math.atan2(y, x);
	var radius = Math.sqrt(x * x + y * y);
	polar += angle;
	return {x: radius * Math.cos(polar), y: radius * Math.sin(polar)}
}
// ZzFXmicro - Zuper Zmall Zound Zynth - MIT License - Copyright 2019 Frank Force
zzfx_v=.5;zzfx_x=new AudioContext;zzfx=(e,f,a,b,d,g,h,k,l)=>{let S=44100,P=Math.PI;a*=2*P/S;a*=1+f*(2*Math.random()-1);g*=1E3*P/(S**2);b=0<b?S*(10<b?10:b)|0:1;d*=b|0;k*=2*P/S;l*=P;f=[];for(var m=0,n=0,c=0;c<b;++c)f[c]=e*zzfx_v*Math.cos(m*a*Math.cos(n*k+l))*(c<d?c/d:1-(c-d)/(b-d)),m+=1+h*(2*Math.random()-1),n+=1+h*(2*Math.random()-1),a+=g;e=zzfx_x.createBuffer(1,b,S);a=zzfx_x.createBufferSource();e.getChannelData(0).set(f);a.buffer=e;a.connect(zzfx_x.destination);a.start();return a}
function shipTaskLookAt(ship, angle)
{
	ship.ai.task = {target: angle, type: 0};
}

function shipBehaviourLand(ship, planet)
{
	ship.frame = planet;
	ship.ai.beh = {type: 0, motorTimer: 0.0};
}


function shipBehaviourOrbit(ship, planet, radius)
{
	ship.frame = planet;
	ship.ai.beh = {type: 1, radius: radius, injection: false, maintain: false, predictTimer: 4.0, palt: 0.0};
}



function aiLookAt(ship, dt, task)
{
	// 0->2PI
	var shipsane = sanitizeAngle(ship.rot);
	var diff = angleDiff(shipsane, task.target);


	var next = sanitizeAngle(ship.rot + ship.angspeed * dt);
	var nextDiff = angleDiff(next, task.target);

	var diffDiff = Math.abs(nextDiff) - Math.abs(diff);

	var speed = 1.0;
	if(Math.abs(diff) <= 1.0)
	{
		speed = Math.max(1.0 * Math.abs(diff) * Math.abs(diff), 0.6);
	}

	if(diffDiff < 0.0)
	{
		// We are going on the right direction
		if(Math.abs(ship.angspeed) >= Math.min(Math.abs(diff) * 2.0, 1.0))
		{
			if(Math.abs(diff) <= Math.PI / 4.0)
			{
				ship.thrust.rot = -Math.sign(diff) * speed * 0.1;
			}
			else 
			{
				ship.thrust.rot = 0.0;
			}
		
		}
	}
	else 
	{
		// We are going away
		ship.thrust.rot = -Math.sign(diff) * speed * 1.4;
	}

	if(Math.abs(diff) <= 0.01 && Math.abs(ship.angspeed) <= 0.1)
	{
		ship.angspeed = 0.0;
		ship.rot = task.target;
		ship.thrust.rot = 0.0;
	}

	return Math.abs(diff);
}

function isEnemy(ourSide, otherSide)
{
	if(ourSide == 0)
	{
		return otherSide == 1;
	}
	else 
	{
		return otherSide != ourSide;
	}
}


function updateShipAI(ship, dt)
{
	var a = noise.perlin2(ship.ai.targetTimer + time * 3.0, ship.ai.targetTimer + time * 2.0) * ship.ai.acc;
	
	if(ship.ai.target != -1 && !ship.destroyed)
	{
		var target = ships[ship.ai.target];
		if(target != undefined)
		{
			var otarget = {x: target.x, y: target.y};
		
			// Trailing

			otarget.x += (target.speed.x - ship.speed.x) * a;
			otarget.y += (target.speed.y - ship.speed.y) * a;
			
			aimShipGuns(ship, otarget, dt);
		}
	}
	// Add some trailing

	function findTarget()
	{
		if(ship.side == 1)
		{
			if(rrg(0, 1000) >= 700)
			{
				ship.ai.target = 0;
			}
		}
		
		ship.ai.target = -1;
		for(var i = 0; i < ships.length; i++)
		{
			if(isEnemy(ship.side, ships[i].side) && rrg(0, 1000) >= 600)
			{
				found = true;
				ship.ai.target = i;
			}
		}
	}

	var lookDev = 1000.0;

	ship.ai.targetTimer -= dt;
	if(ship.ai.targetTimer <= 0.0)
	{
		findTarget();
		if(ship.ai.target == -1)
		{
			ship.ai.targetTimer = rrg(1, 5);
		}
		else 
		{
			ship.ai.targetTimer = rrg(3, 16);
		}
	}

	if(ship.ai.target != -1)
	{
		ship.firing = true;
	}
	else 
	{
		ship.firing = false;
	}

	// Tasks are low-level actuations over the ship
	if(ship.ai.task != null)
	{
		if(ship.ai.task.type == 0)
		{
			lookDev = aiLookAt(ship, dt, ship.ai.task);
		}
	}

	// Behaviour are medium-term, high level acts
	if(ship.ai.beh != null)
	{
		var beh = ship.ai.beh;

		if(beh.type == 0)
		{
			// Land on frame planet
			shipTaskLookAt(ship, getProgradeAngle(ship) + Math.PI)
			
			var prevThrust = ship.thrust.fw;

			if(lookDev <= 0.02 && getFrameSpeed(ship) >= 10.0 && beh.motorTimer <= 0.0)
			{
				ship.thrust.fw = 1.0;
			}
			else 
			{
				ship.thrust.fw = 0.0;
				if(getAltitudeGround(ship) <= 200.0 && prevThrust != 0.0)
				{
					beh.motorTimer = 1.0;
				}
			}

			beh.motorTimer -= dt;

			if(ship.landed)
			{
				ship.ai.beh = null;
				ship.ai.task = null;
				ship.thrust.fw = 0.0;
			}


		}
		else if(beh.type == 1)
		{
			// Take off to orbit
			

			var alt = getAltitudeGround(ship);
			var calt = getAltitude(ship);
			var frame = planets[ship.frame];

			if(beh.maintain)
			{
				beh.predictTimer -= dt;

				if(beh.predictTimer <= 0.0)
				{
					predictShip(ship);
					beh.predictTimer = 4.0;
				}

				

				shipTaskLookAt(ship, getProgradeAngle(ship));

				if(alt < 10.0)
				{
					shipBehaviourOrbit(ship, ship.frame, beh.radius * 1.4);
				}

				if(ship.landed)
				{
					ship.frame = ship.coll.planet;
					shipBehaviourOrbit(ship, ship.coll.planet, beh.radius * 1.4);
				}

				if(lookDev < 0.1)
				{
					if(alt < beh.radius * 0.8)
					{
						ship.thrust.side = -0.05;
					}
					else if(alt > beh.radius * 1.2)
					{
						ship.thrust.side = 0.05;
					}
					else 
					{
						ship.thrust.side = 0.0;
						ship.thrust.fw = 0.0;
					}
				}
				else 
				{
					ship.thrust.fw = 0.0;
					ship.thrust.side = 0.0;
				}
			}
			else
			{
				if(beh.injection) 
				{
					shipTaskLookAt(ship, beh.angle);
					ship.thrust.fw = 1.0;

					if(getFrameSpeed(ship) >= orbitSpeed(planets[ship.frame].mass, 0.001, calt))
					{
						beh.radius = alt;
						ship.thrust.fw = 0.0;
						beh.maintain = true;
					}
				}
				else 
				{

					if(alt <= beh.radius / 2.0)
					{
						shipTaskLookAt(ship, Math.atan2(ship.y - frame.y, ship.x - frame.x) - Math.PI / 2.0);
						ship.thrust.fw = 1.0;
					}
					else if(alt >= beh.palt)
					{
						// Rotate
						shipTaskLookAt(ship, Math.atan2(ship.y - frame.y, ship.x - frame.x));
						ship.thrust.fw = 0.0;
					}
					else
					{
						// Circularize, we are at apoapsis
						if(beh.angle == undefined)
						{
							beh.angle = Math.atan2(ship.y - frame.y, ship.x - frame.x);
						}
						
						shipTaskLookAt(ship, beh.angle);
						ship.thrust.fw = 0.0;

						lookDev = aiLookAt(ship, dt, ship.ai.task);

						if(lookDev <= 0.1)
						{
							beh.injection = true;
						}
						
					}
				}
			}

			beh.palt = alt;
		}
	}

}
function shoot(x, y, vx, vy, side, size, time)
{
	bullets.push({x: x, y: y, vx: vx, vy: vy, side: side, size: size, timer: time, color: sideColor(side)});
}


function updateBullet(bullet, dt)
{
	bullet.x += bullet.vx * dt;
	bullet.y += bullet.vy * dt;
	var acc = gravity(bullet, time);
	bullet.vx += acc.x * dt;
	bullet.vy += acc.y * dt;

	var damage = bullet.size;

	var collAll = collidesWithAny(bullet, time, bullet.side);

	if(collAll.ship != null)
	{
		explode(bullet.x, bullet.y, collAll.ship.speed.x, collAll.ship.speed.y, bullet.size * 17.0, 2.4, 0.4, true, false);
		collAll.ship.health -= damage;
		collAll.ship.health = Math.floor(collAll.ship.health);
		
		return true;
	}
	
	if(collAll.planet != null)
	{
		var coll = collAll.planet;
		var planet = planets[coll.planet];
		var planetVel = orbitVelocity(planet.center, planet.mass, planet.orbitRadius, time, planet.orbitOffset);
		explode(bullet.x, bullet.y, planetVel.x, planetVel.y, bullet.size * 17.0, 2.4, 0.4, true, false);

		if(collAll.city != null)
		{
			// Only player bullets can damage, a bit of a workaround
			if(bullet.side == 2)
			{
				var coll = collAll.city;
				var planet = planets[coll.planet];
				var city = planet.cities[coll.idx];
				city.health -= damage * 0.5;
				if(planet.warTime <= 0.0)
				{
					planet.firstWave = true;
				}

				planet.warTime = 60.0;
	

				if(city.health <= 0.0)
				{
					explode(coll.rx, coll.ry, planetVel.x, planetVel.y, city.size * 7.0, 1.5, 1.0, true, false);
					planet.cities.splice(coll.idx, 1);
					planet.maxForces = getMaxForces(planet);
				}


			}
			
		}

		return true;
	}




	bullet.timer -= dt;
	if(bullet.timer <= 0.0)
	{
		return true;
	}

	return false;
}

function drawBullet(bullet)
{
	ctx.strokeStyle = 'rgb(255, 200, 200)';
	ctx.strokeStyle = bullet.color;
	ctx.lineWidth = bullet.size / (camera.zoom * 1.5);
	ctx.beginPath();
	ctx.moveTo(bullet.x, bullet.y);
	var vnorm = normalize(bullet.vx - ships[0].speed.x, bullet.vy - ships[0].speed.y);
	ctx.lineTo(bullet.x - vnorm.x * bullet.size * 5.0, bullet.y - vnorm.y * bullet.size * 5.0);
	ctx.stroke();
}
function explode(x, y, vx, vy, size, speed, shock, bright, isShoot, volBoost = 0.5)
{
	var expl = {x: x, y: y, vx: vx, vy: vy, time: 0.0, size: size, speed: speed, shock: shock, bright: bright};
	explosions.push(expl);

	explosionSound(size / 100.0, x, y, isShoot, volBoost);

}

function burn(x, y, vx, vy, size, speed)
{
	var f = {x: x, y: y, vx: vx, vy: vy, time: 0.0, size: size, speed: speed};
	fire.push(f);

}

function drawFire(fire)
{
	ctx.beginPath();
	var fireTime = Math.pow(fire.time, 2.0);
	var fcol = [255, 220, 200];
	var mix = [0, 0, 0];
	for(var i = 0; i < 3; i++)
	{
		mix[i] = 70 * fireTime + fcol[i] * (1.0 - fire.time);
	}

	ctx.fillStyle = 'rgba(' + mix[0] + ', ' + mix[1] + ', ' + mix[2] + ', ' + (1.0 - Math.sqrt(fire.time)) + ')';

	var size = Math.sqrt(fire.time) * fire.size;
	ctx.arc(fire.x, fire.y, size, 0.0, Math.PI * 2.0);
	ctx.fill();
}

function drawExplosion(expl)
{
	if(expl.time <= 0.1 * expl.speed && expl.bright == true)
	{
		drawBright(expl.x, expl.y, expl.size / 256.0, 128);
	}

	if(expl.shock != 0)
	{
		ctx.fillStyle = 'rgba(255, 255, 255, ' + (1.0 - Math.pow(expl.time, 1.0 / 3.5)) + ')';

		ctx.beginPath();
		ctx.arc(expl.x, expl.y, Math.pow(expl.time * 4.0, 1.0 / 2.5) * expl.size * expl.shock, 0.0, Math.PI * 2.0);
		ctx.fill();
	}
}

function updateExplosion(expl, dt)
{
	expl.time += dt * expl.speed;
	expl.x += expl.vx * dt;
	expl.y += expl.vy * dt;

	if(expl.time >= 1.0)
	{
		return true;
	}

	return false;
}

function updateFire(fire, dt)
{
	fire.time += dt * fire.speed;
	fire.x += fire.vx * dt;
	fire.y += fire.vy * dt;

	if(fire.time >= 1.0)
	{
		return true;
	}

	return false;
}
var rockNames = ["Lygkos", "Lithos", "Guamedo", "Eadu", "Anoth", "Dikti", "Big Iron", "Impetu"]
var terraNames = ["Delphi", "Trapani", "Erytrae", "Gaia", "Boston", "Jericho", "Nile", "New London"];
var gasNames = ["Bespin", "Nuvo", "New Jupiter", "Vol", "Lightbulb", "Big Boy"];
var desertNames = ["Rhodes", "New Jairo", "Jakku", "Savareen", "Arrakis", "New Sahara"]


// Init
let previousTime = 0.0;

var time = 0.0;

var canvas = document.getElementById("canvas");
canvas.width = window.innerWidth * 1.0;
canvas.height = window.innerHeight * 1.0;

var ctx = canvas.getContext("2d");
var starFieldSize = Math.floor(Math.max(canvas.width, canvas.height) * (1.0 + Math.sqrt(2)));
var starFieldData = ctx.createImageData(starFieldSize, starFieldSize);
var starFieldImage;

var brightSize = 768;
var brightData = ctx.createImageData(brightSize, brightSize);
var brightImage;



var planets = Array();
var planetCount = rrg(9, 14);

var explosions = Array();
var bullets = Array();
var fire = Array();

var sun;

// Ship 0 is always the player ship
var ships = Array();
var rings = Array();

var camera = {x: 0, y: 0, zoom: 0.5};
var aimPoint = {x: 0, y: 0}
var mousePos = {x: 0, y: 0}


var thrustSpeed = 1.0;

var mapMode = 0.0;


var shipMass = 0.001;

var timestep = 1.0;
var dtval = 0.0;
var lockCamera = false;

var timestepVals = [0.0, 1.0, 2.0, 4.0, 10.0, 25.0, 50.0, 100.0];
var timestepVal = 0;
var eventTimer = 0.0;
var eventStr = "";

// Player "inventory"
var plOre = 0.0;
var plMoney = 5000.0;
var plHasFreighter = false;
var plHasDestroyer = false;
var plLevels = [1, 1, 1];
var plHealths = [0, 0, 0];

var playerShipSeed = rrg(0, 10000);

var controls = 0.0;

generateStarfield();
generateBright();
generate();

sun.name = "The Sun";

// Find terra planet
var terra = 1;
for(var i = 0; i < planets.length; i++)
{
	if(planets[i].type == 1)
	{
		terra = i;
		planets[i].name = "New Earth";
		planets[i].cities = [];
		createCities(planets[i], 0.5, 0);
		break;
	}
}

ships.push(createShip(0, playerShipSeed, 2, plLevels[0]));
putShipInOrbit(ships[0], terra, 800.0, 0.0, true);
ships[0].predict = new Array();
ships[0].frame = terra;

var chooseFrame = false;
var chooseFocus = false;
var predictTimer = 0.0;

var camFocus = -1;

var tooltipTime = 0.0;
var tooltipFocus = -1;
var tooltipEnabled = false;

var mineTimer = 0.0;

var tutShown = false;

var hideHud = false;

timestep = 0.0;


function update()
{
	var dt = dtval;



	for(var nn = 0; nn < timestep; nn++)
	{
		var dt = dtval;
		mineTimer -= dt;
		/*if(timestep > 1)
		{
			dt = dt * 2.0;
		}*/


		anyAtWar = false;

		for(var i = 1; i < planets.length; i++)
		{
			var planet = planets[i];
	
			updateWar(planet, dt);

			var cx = planets[planet.center].x;
			var cy = planets[planet.center].y;
			var cmass = planets[planet.center].mass;
	
			var planetPos = orbit(cx, cy, cmass, planet.mass, planet.orbitRadius, time + planet.orbitOffset);
			planet.x = planetPos.x; planet.y = planetPos.y;
		}

		if(anyAtWar)
		{
			selectSong = 2;
		}
		else 
		{
			selectSong = 0;

			if(ships[0] != undefined && ships[0].landed)
			{
				var planet = planets[ships[0].coll.planet];

				if(planet.type == 0 || planet.type == 3 || planet.type == 4)
				{
					selectSong = 1;	// Rocky
				}
				else if(planet.type == 2)
				{
					selectSong = 3;	// Desert
				}
				else if(planet.type == 1)
				{
					selectSong = 4;	// Terra
				}
				else 
				{
					selectSong = 1;
				}
			}
		
		}
		

		if(dtval > 0.0)
		{
			for(var i = 0; i < ships.length; i++)
			{
				var ship = ships[i];

				if(ship != undefined)
				{
					if(i > 0)
					{
						updateShipAI(ship, dt);
					}
					else 
					{
						aimShipGuns(ship, aimPoint, dt);
					}

					if(simulateShip(ship, dt))
					{
						if(i != 0)
						{
							ships.splice(i, 1);
							var idx = Math.abs(camFocus + 1);

							if(idx == i)
							{
								camFocus = -1;
							}

							i--;
						}
					}
				}
			}
			
			for(var i = 0; i < explosions.length; i++)
			{
				if(updateExplosion(explosions[i], dt))
				{
					explosions.splice(i, 1);
					i--;
				}
			}

			for(var i = 0; i < fire.length; i++)
			{
				if(updateFire(fire[i], dt))
				{
					fire.splice(i, 1);
					i--;
				}
			}

			for(var i = 0; i < bullets.length; i++)
			{
				if(updateBullet(bullets[i], dt))
				{
					bullets.splice(i, 1);
					i--;
				}
			}

			time = time + dt;			
		}

	}
	
	if(dtval > 0.0)
	{
		aimPoint = {x: mousePos.x, y: mousePos.y};
		aimPoint.x -= canvas.width / 2.0;
		aimPoint.y -= canvas.height / 2.0;

		if(lockCamera)
		{

			var rrot = ships[0].rot + Math.PI;
			var rot = rotate(aimPoint.x, aimPoint.y, rrot);
			aimPoint.x = rot.x; aimPoint.y = rot.y;
		}

		aimPoint.x *= 1.0 / camera.zoom;
		aimPoint.y *= 1.0 / camera.zoom;

		aimPoint.x += camera.x;
		aimPoint.y += camera.y;
		
		if(camFocus < 0)
		{
			var idx = Math.abs(camFocus + 1);
			if(ships[idx] != undefined)
			{
				camera.x = ships[idx].x;
				camera.y = ships[idx].y;
			}
		}
		else
		{
			camera.x = planets[camFocus].x;
			camera.y = planets[camFocus].y;
		}
		

		var coll = collidesWithAny(aimPoint, time, -1, 0.5 / camera.zoom);

		if(chooseFrame)
		{
			if(coll.planet != null)
			{
				if(ships[0].frame != coll.planet.planet)
				{
					ships[0].frame = coll.planet.planet;
					showEvent("Reference frame set to " + planets[coll.planet.planet].name, 2.0);
				}
			}
		}

		if(chooseFocus)
		{
			var oldFocus = camFocus;

			if(coll.ship != null)
			{
				camFocus = -(coll.ship.idx + 1);
			}
			else if(coll.planet != null)
			{
				camFocus = coll.planet.planet;
			}		

			if(oldFocus != camFocus)
			{
				if(camFocus < 0)
				{
					var idx = Math.abs(camFocus + 1);
					var prefix = "player";
					if(ships[idx].side == 0)
					{
						prefix = "human";
					}
					else if(ships[idx].side == 1)
					{
						prefix = "ai";
					}

					showEvent("Focusing on " + prefix + " ship", 2.0);
				}
				else 
				{
					showEvent("Focusing on " + planets[camFocus].name, 2.0);
				}
			}
		}

		if(coll.planet == null)
		{
			tooltipTime = 0.0;
			tooltipFocus = -1;
		}
		else 
		{
			if(coll.planet.planet != tooltipFocus)
			{
				tooltipTime = 0.0;
				tooltipFocus = coll.planet.planet;
			}
		}

	

		if(predictTimer < 0.0 || ships[0].thrust.fw != 0.0 || ships[0].thrust.side != 0.0)
		{
			predictShip(ships[0]);
			predictTimer = 0.5;
		}
		else 
		{
			predictTimer -= dt;
		}

	


		zoomSpeed -= zoomSpeed * dtval * 3.0;
		if(Math.abs(zoomSpeed) <= 0.1)
		{
			zoomSpeed = 0.0;
		}

		camera.zoom += camera.zoom * zoomSpeed * dtval * 0.8;

		if(camera.zoom <= 0.16)
		{	
			mapMode = Math.max(Math.min(0.02 / camera.zoom, 1.0), 0.0);
		}
		else
		{
			mapMode = 0.0;
		}

		tooltipTime += dt;
		eventTimer -= dt;
		controls -= dt;

		if(!tutShown)
		{
			showEvent("Please read the manual, press F1 to show controls", 5.0);
			tutShown = true;
		}

		music(dt);
	}


}

var totalAI = 0;
var totalHuman = 0;

function render()
{
	totalAI = 0;
	totalHuman = 0;

	ctx.setTransform(1, 0, 0, 1, 0, 0);

	ctx.translate(canvas.width / 2.0, canvas.height / 2.0);
	
	if(lockCamera)
	{
		ctx.rotate(-ships[0].rot - Math.PI);
	}

	ctx.translate(-starFieldSize / 2.0 - canvas.height / 2.0, -starFieldSize / 2.0 - canvas.width / 2.0);

	ctx.drawImage(starFieldImage, 0.0, 0.0);

	doCameraTransform();

	for(var i = 0; i < rings.length; i++)
	{
		drawRing(rings[i], time);
	}

	drawBright(0, 0, 125, 1.0);

	for(var i = 1; i < planets.length; i++)
	{
		drawPlanet(planets[i]);
	}

	for(var i = 0; i < ships.length; i++)
	{
		drawShip(ships[i]);
	}

	for(var i = 1; i < planets.length; i++)
	{
		drawPlanetOver(planets[i]);
	}

	for(var i = 1; i < planets.length; i++)
	{
		drawPlanetShadow(planets[i]);
	}

	for(var i = 0; i < ships.length; i++)
	{
		drawShipExhaust(ships[i]);
	}

	for(var i = 0; i < explosions.length; i++)
	{
		drawExplosion(explosions[i]);
	}

	for(var i = 0; i < bullets.length; i++)
	{
		drawBullet(bullets[i]);
	}

	for(var i = 0; i < fire.length; i++)
	{
		drawFire(fire[i]);
	}

	if(!hideHud)
	{

		if(mapMode > 0.0)
		{
			ctx.globalAlpha = mapMode;

			for(var i = 1; i < planets.length; i++)
			{
				drawPlanetMap(planets[i]);
			}

			for(var i = 0; i < ships.length; i++)
			{
				drawShipMap(ships[i]);
			}


			ctx.globalAlpha = 1.0;
		}

		drawShipHud(ships[0]);

		if(tooltipFocus > 0 && tooltipEnabled)
		{
			drawTooltip(planets[tooltipFocus], aimPoint.x, aimPoint.y);
		}

		ctx.setTransform(1, 0, 0, 1, 0, 0);
		// Static GUI

		if(eventTimer >= 0.0)
		{
			ctx.globalAlpha = eventTimer;
			
			var size = getTextSize(eventStr, 2.0);
			drawText(eventStr, canvas.width / 2.0 - size / 2.0, 20.0, 2.0, 'white');
			ctx.globalAlpha = 1.0;
		}

		if(timestep == 0)
		{
			var str = "Paused";
			var size = getTextSize(str, 2.0);
			drawText(str, canvas.width / 2.0 - size / 2.0, 50.0, 2.0, 'white');
		}

		if(controls >= 0.0)
		{
			ctx.globalAlpha = controls;
			var ctrls = [
				"W", "Forward",
				"S", "Backwards",
				"A", "Rotate CCW",
				"D", "Rotate CW",
				"Q", "Strafe Left",
				"E", "Strafe Right",
				"L", "Lock Camera",
				"T", "Show Tooltip",
				",/.", "Timewarp",
				"LMB", "Fire guns",
				"RMB", "Ref. Frame",
				"MMB", "Focus Camera",
				"Wheel", "Zoom",
			]

			for(var i = 0; i < ctrls.length; i+=2)
			{
				drawText(ctrls[i], 5.0, 100.0 + i * 10.0, 2.0, 'white');
				drawText(ctrls[i + 1], 65.0, 100.0 + i * 10.0, 2.0, 'white');
			}
			ctx.globalAlpha = 1.0;
		}

		drawGeneralHUD();
	}

}

const loop = time => 
{
	const ndt = time - previousTime;
	previousTime = time;
	dtval = ndt / 1000.0;
	update();
	render();
	window.requestAnimationFrame(loop);
};

window.requestAnimationFrame(time => 
{
	previousTime = time;
	loop(time);
});


function onkey(evt)
{
	var release = evt.type == "keyup";

	var key = evt.code;
	var thrust = ships[0].thrust;


	var val = 1.0;
	if(release)
	{
		val = 0.0;
	}

	if(key == 'KeyT')
	{
		tooltipEnabled = !release;
	}

	if(key == 'KeyW')
	{
		thrust.fw = val;
	}
	else if(key == 'KeyS')
	{
		thrust.fw = -val;
	}
	else if(key == 'KeyA')
	{
		thrust.rot = -val;
	}
	else if(key == 'KeyD')
	{
		thrust.rot = val;
	}
	else if(key == 'KeyQ')
	{
		thrust.side = -val;
	}
	else if(key == 'KeyE')
	{
		thrust.side = val;
	}

	if(timestep > 2.0)
	{
		thrust.fw = 0.0; thrust.rot = 0.0; thrust.side = 0.0;
	}


	if(!release)
	{

		if(key == 'KeyL')
		{
			lockCamera = !lockCamera;
			if(lockCamera)
			{
				showEvent("Camera locked", 2.0);
			}
			else 
			{
				showEvent("Camera free", 2.0);
			}
		}
		
		if(key == 'Period')
		{
			timestepVal++;
			if(timestepVal > timestepVals.length - 1)
			{
				timestepVal = timestepVals.length - 1;
			}
			else 
			{
				timestep = timestepVals[timestepVal];
				showEvent(timestep.toString() + "x Timewarp", 2.0);
			}
		}

		if(key == 'Comma')
		{
			timestepVal--;
			if(timestepVal < 0)
			{
				timestepVal = 0;
			}
			else 
			{
				timestep = timestepVals[timestepVal];
				showEvent(timestep.toString() + "x Timewarp", 2.0);
			}
		}

		if(key == 'F1')
		{
			controls = 2.0;
			evt.preventDefault();
		}
		else if(key == 'F2')
		{
			hideHud = !hideHud;
			evt.preventDefault();
		}
	}

	if(ships[0].landed)
	{
		planetShop(key, release, ships[0], planets[ships[0].coll.planet]);
	}
}

var zoomSpeed = 0.0;

function onwheel(evt)
{
	zoomSpeed -= Math.sign(evt.deltaY);
}

function onmouse(evt)
{
	var down = evt.type == "mousedown";

	if(evt.which == 1) // Left click
	{
		ships[0].firing = down;
	}
	else if(evt.which == 2) // Center click
	{
		chooseFocus = down;
		evt.preventDefault();
	}
	else if(evt.which == 3)	// Right click
	{
		chooseFrame = down;
	}
}

function mousemove(evt)
{
	var pos = getMousePos(canvas, evt);
	mousePos.x = pos.x;
	mousePos.y = pos.y;
}

function getMousePos(canvas, evt) 
{
    var rect = canvas.getBoundingClientRect();
    return {
      x: evt.clientX - rect.left,
      y: evt.clientY - rect.top
    };
}

canvas.addEventListener("wheel", onwheel);
canvas.addEventListener("mousemove", mousemove, false);
canvas.addEventListener("mousedown", onmouse, false);
canvas.addEventListener("mouseup", onmouse, false);
document.onkeydown = document.onkeyup = onkey;

var dark = 'rgba(0, 0, 0, 0.8)';

function drawTooltip(planet, x, y)
{
	ctx.globalAlpha = tooltipTime * 4.0;

	function nl()
	{
		xoff = 0.0;
		yoff += 16.0 / camera.zoom;
	}

	if(lockCamera)
	{
		ctx.translate(x, y);
		ctx.rotate(ships[0].rot + Math.PI);
		ctx.translate(-x, -y);
	}


	var cwidth = 320;
	ctx.fillStyle = dark;
	ctx.strokeStyle = 'rgb(255, 255, 255)';
	ctx.beginPath();
	ctx.rect(x, y, cwidth / camera.zoom, 350 / camera.zoom);
	ctx.fill();
	ctx.stroke();

	var margin = 8 / camera.zoom;

	var titleColor = 'rgb(255, 220, 200)';
	var textColor = 'rgb(255, 255, 255)';

	// Draw stuff
	var xoff = 0.0;
	var yoff = 0.0;
	xoff += drawText("Name: ", x + margin, y + margin, 2.0 / camera.zoom, titleColor);
	xoff += drawText(planet.name, x + margin + xoff, y + margin, 2.0 / camera.zoom, textColor);

	nl();

	var humanCities = 0;
	var aiCities = 0;
	if(planet.cities != undefined)
	{
		for(var i = 0; i < planet.cities.length; i++)
		{
			if(planet.cities[i].side == 0)
			{
				
				humanCities++;
			}
			else 
			{
				aiCities++;
			}
		}
	}

	if(humanCities == 0 && aiCities == 0)
	{
		xoff += drawText("Planet is uninhabited", x + margin, y + margin + yoff, 2.0 / camera.zoom, titleColor);

		nl();

		// Ores and stuff
		xoff += drawText("Ore: ", x + margin, y + margin + yoff, 2.0 / camera.zoom, titleColor);
		xoff += drawText(planet.ore.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
	}
	else 
	{
		xoff += drawText("Cities: ", x + margin, y + margin + yoff, 2.0 / camera.zoom, titleColor);
		xoff += drawText(humanCities.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, 'rgb(0, 255, 0)');
		xoff += drawText(" / ", x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText(aiCities.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, 'rgb(255, 0, 0)');

		nl();

		// Ships and stuff
		xoff += drawText("Human Ships: ", x + margin, y + margin + yoff, 2.0 / camera.zoom, titleColor);
		xoff += drawText(planet.humanForces.length.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText(" / ", x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText(planet.maxForces.human.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText("  Resources: ", x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, titleColor);
		xoff += drawText(Math.floor(planet.humanAggro * 100).toString() + "%", x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);

		xoff = margin * 2.0;
		yoff += 32.0 / camera.zoom;

		function drawShipUI(forces)
		{
			for(var i = 0; i < forces.length; i++)
			{
				var shipSize = 0.15 / camera.zoom;
	
				ctx.translate(x + xoff, y + yoff);
				ctx.scale(shipSize, shipSize);
				drawShipLow(forces[i]);
				ctx.scale(1.0 / shipSize, 1.0 / shipSize);
				ctx.translate(-x - xoff, -y - yoff);
	
	
				xoff += shipSize * 128.0;
				if(xoff >= cwidth / camera.zoom - margin)
				{
					xoff = margin * 2.0;
					yoff += shipSize * 350.0;
				}
			}
		}

		// Draw all ships
		drawShipUI(planet.humanForces);

		yoff += 64.0 / camera.zoom;
		xoff = 0.0;

		xoff += drawText("AI Ships: ", x + margin, y + margin + yoff, 2.0 / camera.zoom, titleColor);
		xoff += drawText(planet.aiForces.length.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText(" / ", x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);
		xoff += drawText(planet.maxForces.ai.toString(), x + margin + xoff, y + margin + yoff, 2.0 / camera.zoom, textColor);

		xoff = margin * 2.0;
		yoff += 32.0 / camera.zoom;

		// Draw all ships
		drawShipUI(planet.aiForces);
	}

	
	doCameraTransform();

	ctx.globalAlpha = 1.0;
}


function drawShipHud(ship)
{
	ctx.strokeStyle = 'rgb(204,168,255)';
	ctx.lineWidth = Math.max(1.0 / camera.zoom, 1.0);

	if(camera.zoom <= 1.5 && camera.zoom >= 1.0)
	{
		ctx.globalAlpha = 1.0 - (camera.zoom - 1.0) * 2.0;
	}

	if(camera.zoom <= 1.5 && !ship.landed)
	{

		// Predicted orbit
		if(ship.predict != undefined)
		{
			ctx.beginPath();
			var frame = planets[ship.frame];

			for(var i = 0; i < ship.predict.length; i++)
			{
				var frameThen = planetAtTime(ship.frame, ship.predict[i].time);

				var px = ship.predict[i].x - frameThen.x + frame.x;
				var py = ship.predict[i].y - frameThen.y + frame.y;

				if(i == 0)
				{
					ctx.moveTo(px, py);
				}
				else
				{

					ctx.lineTo(px, py);
				}
			}

			ctx.stroke();
		}	

	}

	ctx.globalAlpha = 1.0;

	var size = 42.0;
	var rsize = Math.max(size / camera.zoom, size);
	ctx.strokeStyle = 'rgb(128, 128, 128)';
	ctx.lineWidth = Math.max(2.0 / camera.zoom, 2.0);
	ctx.beginPath();
	ctx.arc(ship.x, ship.y, rsize, 0.0, Math.PI * 2.0);
	ctx.stroke();



	var prograde = getProgradeVector(ship);
	var retrograde = {x: -prograde.x, y: -prograde.y}
	var normal = {x: -prograde.y, y: prograde.x};
	var antinormal = {x: prograde.y, y: -prograde.x};
	var planet = normalize(ship.acc.x, ship.acc.y);

	ctx.strokeStyle = 'rgb(255,214,117)';
	ctx.beginPath();
	ctx.moveTo(ship.x + prograde.x * rsize * 1.0, ship.y + prograde.y * rsize * 1.0);
	ctx.lineTo(ship.x + prograde.x * rsize * 1.5, ship.y + prograde.y * rsize * 1.5);
	ctx.stroke();
	
	ctx.beginPath();
	ctx.moveTo(ship.x + retrograde.x * rsize * 1.25, ship.y + retrograde.y * rsize * 1.25);
	ctx.lineTo(ship.x + retrograde.x * rsize * 1.5, ship.y + retrograde.y * rsize * 1.5);
	ctx.stroke();


	ctx.strokeStyle = 'rgb(87,188,255)';
	ctx.beginPath();
	ctx.moveTo(ship.x + normal.x * rsize * 1.0, ship.y + normal.y * rsize * 1.0);
	ctx.lineTo(ship.x + normal.x * rsize * 1.5, ship.y + normal.y * rsize * 1.5);
	ctx.stroke();

	ctx.beginPath();
	ctx.moveTo(ship.x + antinormal.x * rsize * 1.25, ship.y + antinormal.y * rsize * 1.25);
	ctx.lineTo(ship.x + antinormal.x * rsize * 1.5, ship.y + antinormal.y * rsize * 1.5);
	ctx.stroke();

	// Planet
	ctx.fillStyle = 'rgb(187,128,255)';
	ctx.beginPath();
	ctx.arc(ship.x + planet.x * rsize, ship.y + planet.y * rsize, rsize / 15.0, 0.0, Math.PI * 2.0);
	ctx.fill();

	ctx.strokeStyle = 'white';
	// Ship orientation
	var forward = {x: Math.cos(ship.rot + Math.PI / 2.0), y: Math.sin(ship.rot + Math.PI / 2.0)};
	ctx.beginPath();
	ctx.moveTo(ship.x + forward.x * rsize * 1.0, ship.y + forward.y * rsize * 1.0);
	ctx.lineTo(ship.x + forward.x * rsize * 1.25, ship.y + forward.y * rsize * 1.25);
	ctx.stroke();
	
}

function drawGeneralHUD()
{
	function nl()
	{
		xoff = 0.0;
		yoff += 16.0;
	}

	var green = 'rgba(166,255,128, 1.0)';
	// Bottom left, orbit info
	var margin = 4.0;

	ctx.strokeStyle = green;
	ctx.lineWidth = 1.0;

	var xoff = 0.0;
	var yoff = 0.0;

	// Right, landed info
	if(ships[0].landed)
	{
		var br0x = canvas.width - 180.0;
		var br0y = canvas.height / 2.0 - 178.0;

		ctx.beginPath();
		ctx.rect(br0x, br0y, 1000.0, 256.0);
		ctx.stroke();

		var at = planets[ships[0].coll.planet];
		var tab0 = 20.0;
		var tab1 = 120.0;
		
		var menuItems = 
		[
			"M", "Mine", NaN,
		]


		if(at.cities != undefined && at.cities.length != 0)
		{
			menuItems = 
			[
				"R", "Repair", repairPrice(),
				"U", "Upgrade", upgradePrice(),
				"S", "Sell Ore", orePrice(),
				"1", "Fighter", 0,
				"2", "Freighter", freighterPrice(),	// Remember, false == 0!
				"3", "Destroyer", destroyerPrice(),	
			]
		}

	
		var ai = 0; 
		var human = 0;

		if(at.cities != undefined && at.cities.length != 0)
		{


			for(var i = 0; i < at.cities.length; i++)
			{
				if(at.cities[i].side == 0)
				{
					human++;
				}
				else 
				{
					ai++;
				}
			}
		}

		var title = "AI World";
		if(human > ai)
		{
			title = "Human World";
		}
		else if(human == 0 && ai == 0)
		{
			title = "Free World";
		}

		xoff += drawText(title, br0x + margin + xoff, br0y + margin + yoff, 2.0, green);

		

		nl();
		nl();

		if(at.warTime > 0.0)
		{
			drawText("Planet is at war", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
			nl();
			drawText(Math.floor(at.warTime) + " until peace", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
		}
		else
		{
			

			for(var i = 0; i < menuItems.length / 3.0; i++)
			{
				drawText(menuItems[i * 3.0 + 0], br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
				xoff = tab0;
				drawText(menuItems[i * 3.0 + 1], br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
				xoff = tab1;
				drawText(priceToString(menuItems[i * 3.0 + 2]), br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
				nl();
			}

		}
		
	}

	// Bottom right, ship info
	var br0x = canvas.width - 180.0;
	var br0y = canvas.height - 64.0;


	ctx.beginPath();
	ctx.rect(br0x, br0y, 1000.0, 1000.0);
	ctx.stroke();

	var xoff = 0.0;
	var yoff = 0.0;
	var tab = 80;
	xoff += drawText("Hull ", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	if(ships[0].health < 0.0)
	{
		xoff += drawText("Destroyed", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	}
	else 
	{
		xoff += drawText(Math.floor(ships[0].health) + "/", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
		xoff += drawText(Math.floor(ships[0].stats.armor).toString(), br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	}
	
	nl();
	xoff += drawText("Cargo ", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(plOre.toString() + "/", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff += drawText(Math.floor(ships[0].stats.cargo).toString(), br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	nl();
	xoff += drawText("Money ", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(plMoney.toString(), br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	nl();
	xoff += drawText("Level ", br0x + margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(ships[0].level.toString(), br0x + margin + xoff, br0y + margin + yoff, 2.0, green);

	ctx.beginPath();
	ctx.rect(-5.0, br0y, 180.0 + 5.0, 1000.0);
	ctx.stroke();

	xoff = 0.0;
	yoff = 0.0;
	tab = 80;

	xoff += drawText("Frame ", margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(planets[ships[0].frame].name, margin + xoff, br0y + margin + yoff, 2.0, green);
	nl();
	xoff += drawText("Speed ", margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(Math.floor(getFrameSpeed(ships[0])).toString(), margin + xoff, br0y + margin + yoff, 2.0, green);
	nl();
	xoff += drawText("Altitude ", margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(Math.floor(getAltitudeGround(ships[0])).toString(), margin + xoff, br0y + margin + yoff, 2.0, green);
	nl();
	xoff += drawText("Total AI ", margin + xoff, br0y + margin + yoff, 2.0, green);
	xoff = tab;
	xoff += drawText(totalAI.toString(), margin + xoff, br0y + margin + yoff, 2.0, green);
}

function generateBright()
{
	for(var y = 0; y < brightSize; y++)
	{
		for(var x = 0; x < brightSize; x++)
		{
			var i = y * brightSize + x;

			var xabs = (x - brightSize / 2.0);
			var yabs = (y - brightSize / 2.0);

			var factor = brightSize / ((xabs * xabs + yabs * yabs) / 6.0);

			var b = factor;
			var polar = Math.atan2(yabs, xabs);
			b += noise.perlin2(polar * 15.0, 0.0) * 0.6;
			b -= 1.0 - Math.pow(factor, 0.03);

			var abbrf = Math.max(1.0 - ((factor - 1.0) * (factor - 1.0)), 0.0);
			var abbgf = Math.max(1.0 - ((factor - 1.2) * (factor - 1.2)), 0.0);
			var abbbf = Math.max(1.0 - ((factor - 1.4) * (factor - 1.4)), 0.0);

			var abbr = noise.perlin2(polar * 8.0, 1.0) * abbrf + abbrf;
			var abbg = noise.perlin2(polar * 16.0, 7.0) * abbgf + abbgf;
			var abbb = noise.perlin2(polar * 32.0, 15.0) * abbbf + abbbf;

			brightData.data[i * 4 + 0] = b * 200 + abbr * 128;
			brightData.data[i * 4 + 1] = b * 160 + abbg * 118;
			brightData.data[i * 4 + 2] = b * 128 + abbb * 98;
			brightData.data[i * 4 + 3] = b * 255;
		}
	}

	brightImage = imageDataToImage(brightData);
}

function generateStarfield()
{
	for(var y = 0; y < starFieldSize; y++)
	{
		for(var x = 0; x < starFieldSize; x++)
		{
			var i = y * starFieldSize + x;

			var r = 0;
			var g = 0;
			var b = 0;

			var noise0 = noise.perlin2(x * 0.001, y * 0.001);
			var noise1 = noise.perlin2(x * 0.01 + noise0, y * 0.01 + noise0);
			var noise2 = noise.perlin2(x * 0.05, y * 0.05);
			var noise3 = noise.perlin2(x * 0.01 + 5.0, y * 0.01 + 5.0);
			
			r = (noise1 + noise2 + noise0) * 255;
			g = r * 0.7 + noise3 * 60;
			b = r * 0.5 + noise3 * 128;

			if(rrg(0, 10000) >= 9995)
			{
				r = 255; g = 255; b = 255;
			}
			else
			{
				var factor = 0.25;
				r = r * factor; g = g * factor; b = b * factor;
			}

			starFieldData.data[i * 4 + 0] = r * 0.6;
			starFieldData.data[i * 4 + 1] = g * 0.6;
			starFieldData.data[i * 4 + 2] = b * 0.6;
			starFieldData.data[i * 4 + 3] = 255;
		}
	}

	starFieldImage = imageDataToImage(starFieldData);
}


function generatePlanet(type, radiusScale, id, moon)
{
	var newPlanet;
	var name;

	var nameSrc;

	if(type == 0)
	{
		// Rocky planet
		var radius = rrg(250, 850) * radiusScale;
		newPlanet = createPlanet(rrg(25, 60), rrg(140, 150), radius, 0.0, 
		randomColor(0, 1.0), randomColor(0, 0.5), randomColor(0, 1.0),
		'0, 0, 0', rrg(0, 10000), 64);
		nameSrc = rockNames;

		if(rrg(0, 1000) >= 850)
		{
			createCities(newPlanet, rrg(-70, 50) * 0.01, srandom());
		}
		else
		{
			newPlanet.ore = rrg(55, radius * radius * 0.0114);
			newPlanet.fuel = rrg(50, 100);
		}
	}
	else if(type == 1)
	{
		// Terra planet
		var radius = rrg(300, 600) * radiusScale;

		newPlanet = createPlanet(rrg(25, 30), rrg(90, 160), 
		radius, radius + rrg(120, 170), randomColor(1, 1.0), randomColor(1, 0.5), randomColor(1, 1.0),
		'120, 120, 255', rrg(0, 10000), 64);

		nameSrc = terraNames;

		createCities(newPlanet, rrg(-70, 100) * 0.01, srandom());
	}
	else if(type == 2)
	{
		// Desert planet
		var radius = rrg(350, 900) * radiusScale;

		newPlanet = createPlanet(rrg(15, 25), rrg(80, 120), 
		radius, radius + rrg(120, 170), randomColor(2, 1.0), randomColor(2, 0.5), randomColor(2, 1.0),
		'255, 120, 120', rrg(0, 10000), 64);

		nameSrc = desertNames;

		if(rrg(0, 1000) >= 200)
		{
			createCities(newPlanet, rrg(-80, 40) * 0.01, srandom());
		}
		else
		{
			newPlanet.ore = rrg(50, radius * radius * 0.004);
			newPlanet.fuel = rrg(200, 500);
		}
	}
	else if(type == 3)
	{
		// Gas giant
		var radius = rrg(700, 1800) * radiusScale;

		var themeColor = randomColor(3, 1.0);
	
		newPlanet = createGasPlanet(radius, radius + rrg(50, 300),
		makeColorAlpha(themeColor), themeColor, randomColor(3, 1.0));

		nameSrc = gasNames;

		newPlanet.ore = 0;
		newPlanet.fuel = rrg(1000, 2000);
	}
	else if(type == 4)
	{
		// Small rocky
		var radius = rrg(20, 150) * radiusScale;
		newPlanet = createPlanet(rrg(25, 60), rrg(140, 150), radius, 0.0, 
		randomColor(0, 1.0), randomColor(0, 0.5), randomColor(0, 1.0),
		'0, 0, 0', rrg(0, 10000), 64);
		nameSrc = rockNames;

		newPlanet.ore = rrg(35, radius * radius * 0.14);
	}

	newPlanet.mass = 4.0 * Math.PI * newPlanet.radius * newPlanet.radius;

	newPlanet.orbitColor = randomColor(-1, 2.0);

	name = nameSrc[id % nameSrc.length];


	if(moon != -1)
	{
		name = planets[moon].name + ' ' + id;
	}


	newPlanet.name = name;

	return newPlanet;
}


function generate()
{

	sun = createStar(0, 0, 5000);

	sun.mass = 375000000;
	sun.sun = true;
	// Planet 0 is sun
	planets.push(sun);

	// Create a set of random planets
	for(var i = 0; i < planetCount; i++)
	{
		var type = rrg(0, 4);
		
		var orbitRadius = rrg(9000, 80000);

		if(type == 1 && (orbitRadius <= 40000 || orbitRadius >= 80000))
		{
			// Terras can only exist in the goldilocks zone
			type = 2;
		}

		var newPlanet = generatePlanet(type, 1.0, i, -1);

		newPlanet.orbitRadius = orbitRadius
		newPlanet.orbitOffset = rrg(-50000, 50000);
		newPlanet.center = 0;
		newPlanet.type = type;

		newPlanet.idx = planets.length;
		planets.push(newPlanet);

	}

	// Create some moons and rings
	for(var i = 1; i < planetCount + 1; i++)
	{
		var moons = rrg(0, planets[i].radius / 300);
		for(var j = 0; j < moons; j++)
		{
			var type = rrg(0, 4);
			if(type == 3)
			{
				type = 0;
			}
			var newPlanet = generatePlanet(type, rrg(25, 60) * 0.01, j + 1, i);

			if(newPlanet.radius >= planets[i].radius * 0.6)
			{
				newPlanet.radius *= 0.5;
				newPlanet.atmoRadius *= 0.5;
			}

			var minOrbit = planets[i].radius + newPlanet.radius * 5.0;
			var maxOrbit = planets[i].orbitRadius / 16000;

			newPlanet.orbitRadius = rrg(minOrbit, minOrbit + planets[i].radius * maxOrbit);
			newPlanet.orbitOffset = rrg(0, 500000);
			newPlanet.center = i;
			newPlanet.type = type;

			newPlanet.idx = planets.length;
			planets.push(newPlanet);
		}

		if(rrg(0, 1000) >= 900 && planets[i].radius >= 150)
		{
			var minRadius = rrg(planets[i].radius * 1.5, planets[i].radius * 8.0);
			var maxRadius = minRadius + rrg(50, 300) * 0.01 * planets[i].radius;
			var density = rrg(80, 400) * 0.0000003;

			var ring = createRing(i, minRadius, maxRadius, density);
			rings.push(ring);

		}
	}

	update(0.0);

	var foundTerra = false, foundDesert = false, minDist = false;

	for(var i = 1; i < planets.length; i++)
	{
		if(planets[i].type == 1)
		{
			foundTerra = true;
		}

		if(planets[i].type == 2)
		{
			foundDesert = true;
		}

		if(i < planetCount)
		{
			for(var j = 1; j < planetCount; j++)
			{
				if(j != i)
				{
					var dist = distance(planets[i].x, planets[i].y, planets[j].x, planets[j].y);
					if(dist <= 9000.0)
					{
						minDist = true;
					}
				}
			}
		}
	}

	if(foundTerra == false || foundDesert == false || rings.length <= 1 || minDist)
	{
		planets = [];
		seed += rrg(1, 5000);
		generate();
	}

}



function createPlanet(nspeed, nheight, radius, atmoRadius, colorInner, colorOuter, colorDetail, colorAtmo, nseed, ncount)
{

	var heights = Array(ncount);
	var bheights = Array(ncount);

	noise.seed(nseed);

	// Generate heights
	for(var i = 0; i < ncount; i++)
	{
		var height0 = noise.perlin2(i / ncount * nspeed * 1.0, 0.0) * nheight;
		var height1 = noise.perlin2(i / ncount * nspeed * 2.0, 5.0) * nheight * 0.5;
		var height2 = noise.perlin2(i / ncount * nspeed * 4.0, 8.0) * nheight * 0.25;
		heights[i] = Math.max(height0 + height1, 0.0) * 1.5;
		bheights[i] = (noise.perlin2(i / ncount * nspeed, 40.0) * nheight + height2) * 0.2;
	}

	

	return {x: 0, y: 0, radius:radius, atmoRadius: atmoRadius, 
		colorInner:colorInner, colorOuter:colorOuter, colorDetail: colorDetail, colorAtmo: colorAtmo,
		 heights: heights, bheights: bheights, isGasPlanet: false, cities: [], ore: 0, fuel: 0};
}

function getMaxForces(planet)
{
	var humanShips = 0;
	var aiShips = 0;
	for(var i = 0; i < planet.cities.length; i++)
	{
		if(planet.cities[i].side == 0)
		{
			humanShips += planet.cities[i].size / 20.0;
		}
		else
		{
			aiShips += planet.cities[i].size / 20.0;
		}
		
	}

	humanShips = Math.min(Math.floor(humanShips), 26);
	aiShips = Math.min(Math.floor(aiShips), 26);

	return {human: humanShips, ai: aiShips};
}

function createForces(planet)
{
	var maxForces = getMaxForces(planet);

	planet.humanForces = [];
	planet.aiForces = [];

	for(var i = 0; i < maxForces.human / 2.0 + maxForces.ai; i++)
	{

		if(i < maxForces.human / 2.0)
		{
			planet.humanForces.push(randomShip(0));
		}
		else 
		{
			planet.aiForces.push(randomShip(1));
		}
	}

	planet.maxForces = maxForces;
	planet.deployed = [];
	planet.warTime = 0.0;
	planet.aiTime = 0.0;
	planet.humanTime = 0.0;
}

// efactor = 0 -> 50%  Enemies
// efactor = 1 -> 100% Enemies
// efactor = -1 -> 0% Enemies
function createCities(planet, efactor, seed)
{
	noise.seed(seed);
	var step = 1.0 / (planet.radius / 34.0);
	// Generate cities for each side
	for(var i = 0; i < 2.0 * Math.PI; i+=step)
	{
		var side = noise.perlin2(i, 0.0) * 1.2;
		if(Math.abs(side) >= 0.2)
		{

			nside =  Math.max(Math.min(side + efactor, 1.0), -1.0);

			var side = 1;
			var size = Math.min(Math.max(Math.abs(side) * 0.07 * planet.radius, 16.0), 40.0);

			if(nside >= 0.0)
			{
				// Human city
				side = 0;
			}

			planet.cities.push({x: Math.cos(i), y: Math.sin(i), size: size, side: side, tone: rrg(80, 200), health: size, mhealth: size});
		}
	}

	createForces(planet);
	planet.humanAggro = rrg(5, 35) * 0.01;
}

var anyAtWar = false;

function updateWar(planet, dt)
{

	if(planet.warTime != undefined)
	{
		planet.warTime -= dt;
		if(planet.warTime <= 0.0)
		{
			// Make forces come back
			for(var i = 0; i < planet.deployed.length; i++)
			{
				shipBehaviourLand(planet.deployed[i], planet.idx);
			}

			planet.deployed = [];
		}
		else 
		{
			anyAtWar = true;
			function spawn(array, count)
			{
				for(var i = 0; i < count; i++)
				{
					if(array.length <= 0)
					{
						return;
					}

					var idx = rrg(0, array.length - 1);
					var force = array[idx];
					array.splice(idx, 1);

					var pos = normalize(rrg(0, 1000) - 500, rrg(0, 1000) - 500);
					pos.x *= planet.radius * 1.02;
					pos.y *= planet.radius * 1.02;
					force.x = planet.x + pos.x;
					force.y = planet.y + pos.y;
					force.rot = Math.atan2(pos.y, pos.x) - Math.PI / 2.0;
					force.speed = getPlanetSpeed(planet, time);

					force.frame = planet.idx;
					shipBehaviourOrbit(force, planet.idx, rrg(60, planet.radius));

					ships.push(force);
					planet.deployed.push(force);

				}
			}

			if(planet.firstWave || planet.wave <= 0.0)
			{
				var aiSpawn = rrg(1, planet.aiForces.length / 2.0);
				var humanSpawn = aiSpawn * planet.humanAggro;

				spawn(planet.aiForces, aiSpawn);
				spawn(planet.humanForces, humanSpawn);
				planet.firstWave = false;
			}


		}
	}
}

function createGasPlanet(radius, atmoRadius, colorAtmo, color0, color1)
{
	return {x: 0, y: 0, radius: radius, atmoRadius: atmoRadius, 
		colorAtmo: colorAtmo, color0: color0, color1: color1, isGasPlanet: true}
}

function drawAtmosphere(x, y, radius, atmoRadius, colorAtmo)
{
	var grd = ctx.createRadialGradient(
		x, y, radius, 
		x, y, atmoRadius);

	grd.addColorStop(0, 'rgba(' + colorAtmo + ',0.5)');
	grd.addColorStop(1, 'rgba(' + colorAtmo + ', 0)');

	ctx.fillStyle = grd;
	ctx.beginPath();
	ctx.arc(x, y, atmoRadius, 0.0, 2.0 * Math.PI);
	ctx.fill();
}

function drawPlanetShadow(planet)
{
	var dist2 = (planet.x * planet.x + planet.y * planet.y);
	var td = Math.sqrt(dist2 + planet.radius * planet.radius);
	var xangle = Math.PI / 2.0 - Math.atan2(-planet.y, -planet.x);
	var angle = Math.acos(planet.radius / td);
	var alpha = xangle - angle;
	var beta = xangle + angle;
	// Draw shadow


	var radius = planet.radius * 1.0;
	if(planet.atmoRadius != 0.0)
	{
		radius = planet.atmoRadius;
	}

	var t0xpos = planet.x + Math.sin(alpha) * radius;
	var t0ypos = planet.y + Math.cos(alpha) * radius;
	var t1xpos = planet.x + Math.sin(beta) * radius;
	var t1ypos = planet.y + Math.cos(beta) * radius;

	var offdist = planet.radius * 32.0;

	var t0l = Math.sqrt(t0xpos * t0xpos + t0ypos * t0ypos);
	var t1l = Math.sqrt(t1xpos * t1xpos + t1ypos * t1ypos);
	var pl = Math.sqrt(dist2);

	var t0xoff = t0xpos / t0l;
	var t0yoff = t0ypos / t0l;
	var t1xoff = t1xpos / t1l;
	var t1yoff = t1ypos / t1l;

	var shgrd = ctx.createLinearGradient(planet.x, planet.y, 
		planet.x + planet.x / pl * offdist, planet.y + planet.y / pl * offdist);

	var ext = 0.005 + Math.max((planet.atmoRadius - planet.radius) / 32000.0, 0.0);

	shgrd.addColorStop(0, 'rgba(0, 0, 0, 0)');
	shgrd.addColorStop(ext, 'rgba(0, 0, 0, 0.8)');
	shgrd.addColorStop(1.0, 'rgba(0, 0, 0, 0)');

	ctx.fillStyle = shgrd;
	ctx.beginPath();

	ctx.moveTo(t0xpos, t0ypos)
	ctx.lineTo(t0xpos + t0xoff * offdist, t0ypos + t0yoff * offdist);
	ctx.lineTo(t1xpos + t1xoff * offdist, t1ypos + t1yoff * offdist);
	ctx.lineTo(t1xpos, t1ypos);
	ctx.closePath();
	ctx.fill();
}

function drawPlanetHeights(planet, array)
{
	ctx.beginPath();

	var ncount = array.length;

	for(var i = 0; i < ncount; i++)
	{
		var ifloat = (i / ncount) * 2.0 * Math.PI;
		var x = Math.cos(ifloat); var y = Math.sin(ifloat);
		var height = array[i] + 15.0;
		x = x * planet.radius + x * height + planet.x; 
		y = y * planet.radius + y * height + planet.y;

		if(i == 0)
		{
			ctx.moveTo(x, y);
		}
		else
		{
			ctx.lineTo(x, y);
		}
	}

	ctx.fill();
}

function drawPlanet(planet)
{
	if(planet.isGasPlanet == true)
	{
		// Draw main circle
		ctx.fillStyle = planet.color0;
		ctx.beginPath();
		ctx.arc(planet.x, planet.y, planet.radius, 0.0, 2.0 * Math.PI);
		ctx.fill();

		drawAtmosphere(planet.x, planet.y, planet.radius, planet.atmoRadius, planet.colorAtmo);
	}
	else
	{

		// Outer circle
		ctx.fillStyle = planet.colorOuter;
		drawPlanetHeights(planet, planet.heights);
	}

	

	if(planet.cities != undefined && planet.cities.length > 0)
	{
		// Draw cities
		for(var i = 0; i < planet.cities.length; i++)
		{

			var city = planet.cities[i];
			var rx = city.x * planet.radius * 0.98 + planet.x;
			var ry = city.y * planet.radius * 0.98 + planet.y;
			var px = -city.y;
			var py = city.x;
			var height = city.size * 3.0;

			if(city.side == 0)
			{
				totalHuman++;
				ctx.fillStyle = 'rgb(' + city.tone + ', ' + city.tone + ', ' + city.tone + ')';
				ctx.strokeStyle = 'rgb(200, 200, 200)';
				ctx.beginPath();
				// Human city, rect
				ctx.moveTo(rx - px * city.size, ry - py * city.size);
				ctx.lineTo(rx + px * city.size, ry + py * city.size);
				ctx.lineTo(rx + px * city.size + city.x * height, ry + py * city.size + city.y * height);
				ctx.lineTo(rx - px * city.size + city.x * height, ry - py * city.size + city.y * height);
				ctx.lineTo(rx - px * city.size, ry - py * city.size);
				ctx.fill();
				ctx.stroke();
			}
			else 
			{
				totalAI++;
				ctx.fillStyle = 'rgb(' + city.tone + ', ' + city.tone * 0.5 + ', ' + city.tone * 0.5 + ')';
				ctx.strokeStyle = 'rgb(200, 128, 128)';

				ctx.beginPath();
				ctx.moveTo(rx - px * city.size * 0.5, ry - py * city.size * 0.5);
				ctx.lineTo(rx + px * city.size * 0.5, ry + py * city.size * 0.5);
				ctx.lineTo(rx + px * city.size * 0.5 + city.x * height, ry + py * city.size * 0.5 + city.y * height);
				ctx.lineTo(rx - px * city.size * 0.5 + city.x * height, ry - py * city.size * 0.5 + city.y * height);
				ctx.fill();

				ctx.beginPath();
				// AI city, ball + 2 rects
				ctx.arc(rx, ry, city.size * 1.0, 0.0, Math.PI * 2.0);
				ctx.stroke();

			}


		}
	}

	
}

function drawPlanetOver(planet)
{
	if(!planet.isGasPlanet)
	{
		// Draw heights
		ctx.fillStyle = planet.colorInner;
		drawPlanetHeights(planet, planet.bheights);

		// Draw inner circle
		// TODO: Could be removed
		ctx.fillStyle = planet.colorDetail;
		ctx.beginPath();
		ctx.arc(planet.x, planet.y, planet.radius, 0.0, 2.0 * Math.PI);
		ctx.fill();
	}

	if(planet.atmoRadius >= 0.0)
	{
		drawAtmosphere(planet.x, planet.y, planet.radius, planet.atmoRadius, planet.colorAtmo);
	}


}

function drawPlanetMap(planet)
{
	
	var center = planets[planet.center];

	ctx.strokeStyle = planet.orbitColor;
	ctx.fillStyle = planet.orbitColor;
	ctx.lineWidth = 1.0 / camera.zoom;

	// Orbit circle
	ctx.beginPath();
	ctx.arc(center.x, center.y, planet.orbitRadius, 0.0, Math.PI * 2.0);
	ctx.stroke();

	// Planet point
	ctx.beginPath();
	ctx.arc(planet.x, planet.y, planet.radius, 0.0, Math.PI * 2.0);
	ctx.fill();

	var textSize = 2.0 / camera.zoom;
	if(planet.center != 0)
	{
		if(camera.zoom <= 0.02)
		{	
			textSize = 0.0;
		}
		else 
		{
			textSize = 1.3 / camera.zoom;
		}
	}

	if(textSize > 0.0)
	{
		var textLength = planet.name.length * 4.0 * textSize;
		drawText(planet.name, planet.x - (textLength / 2.0), planet.y + Math.max(planet.atmoRadius, planet.radius * 1.1), textSize, planet.orbitColor);
	}
}



function createRing(center, minRadius, maxRadius, density)
{
	var surface = Math.PI * maxRadius * maxRadius - Math.PI * minRadius * minRadius;

	var points = surface * density;

	var rocks = Array();

	if(points >= 100)
	{
		points = 100;
	}

	for(var i = 0; i < points; i++)
	{
		var orbitRadius = rrg(minRadius, maxRadius);
		var offset = rrg(-10000, 10000);

		var size = rrg(5, 50);

		var color = randomColor(2, 0.6);

		rocks.push({orbitRadius: orbitRadius, offset: offset, size: size, color: color});
	}

	return {center: center, minRadius: minRadius, maxRadius: maxRadius, rocks: rocks}
}

function maxCameraReach()
{
	var maxSize = Math.max(canvas.width, canvas.height);
	return maxSize / camera.zoom;
}

function drawRing(ring, time)
{
	var cx = planets[ring.center].x;
	var cy = planets[ring.center].y;


	if(camera.zoom >= 0.01 && distance(camera.x, camera.y, cx, cy) <= maxCameraReach() + ring.maxRadius)
	{
		for(var i = 0; i < ring.rocks.length; i++)
		{
			var rock = ring.rocks[i];
			var pos = orbit(cx, cy, planets[ring.center].mass, 0.001, 
				rock.orbitRadius, time + rock.offset);
			ctx.fillStyle = rock.color;
			ctx.beginPath();
			ctx.arc(pos.x, pos.y, rock.size, 0, 2.0 * Math.PI);
			ctx.fill();
		}
	}


}


// A ship is made out of a shaped hull, 
// weapon attachment points, and thrusters
function createShip(type, nseed, side, level)
{
	function h(x, y)
	{
		hull.push({x: x, y: y});
	}

	function t(x, y, s, d)
	{
		thrusters.push({x:x, y:y, size: s, t: 0.0, dir: d});
	}

	let shipValues = [
		// Maneouver, Speed, Armor, Fuel, Cargo
		2.0, 		12.0, 	50.0, 	100.0, 50.0, 	// Fighter
		1.0, 		9.0, 	100.0, 	200.0, 150.0, 	// Freighter
		0.8, 		9.0, 	400.0, 	250.0, 80.0];	// Destroyer

	seed = nseed;

	var stats = {};
	var hull = Array();
	var weapons = Array();
	var thrusters = Array();
	var length;
	var width;

	if(type == 0)
	{
		width = rrg(50, 100) * 0.5;
		length = width * rrg(100, 140) * 0.01;

		// widths per length
		var slope = length / (width * 2.0);

		// Triangle hull
		h(-width / 2.0, 0.0);
		h(width / 2.0, 0.0);
		h(0.0, length);
		h(length * 0.5 * slope, length * 0.5);
		h(width * 0.8, length * 0.5);
		h(-width * 0.8, length * 0.5);
		h(0.0, length * 2.0);
		h(width * 0.8, length * 0.5);
		h(length * 0.5 * slope, length * 0.5);
		h(0.0, length);
		
		// Forwad / Rot thrusters
		var thrusterOff = width * rrg(30, 70) * 0.005;
		t(-thrusterOff, 0.0, 6.0, 0.0);
		t(thrusterOff, 0.0, 6.0, 0.0);
		t(0.0, length * 2.0, 6.0, Math.PI);
		t(0.0, length * 2.0, 6.0, Math.PI / 2.0);
		t(0.0, length * 2.0, 6.0, -Math.PI / 2.0);
		t(thrusterOff, 0.0, 6.0, Math.PI / 2.0);
		t(-thrusterOff, 0.0, 6.0, -Math.PI / 2.0);


		// 2 Weapons
		var lPos = rrg(60, 90) * length * 0.01;
		var weaponOff = lPos * slope * 0.5;

		weapons.push({x: weaponOff, y: lPos, dir: 0, size: 6.0, angle: Math.PI / 2.5, speed: 8.0, ftime: 0.07, ftimer: 0.0});
		weapons.push({x: -weaponOff, y: lPos, dir: 0, size: 6.0, angle: Math.PI / 2.5, speed: 8.0, ftime: 0.07, ftimer: 0.0});

	}
	else if(type == 1)
	{
		// Freighter, jack of all trades
		width = rrg(100, 160) * 0.5;
		length = width * rrg(140, 180) * 0.01;
		var mlength = length * rrg(130, 170) * 0.01;
		var lengthd = mlength - length;

		// Rectangle hull
		h(-width / 2.0, 0.0);
		h(width / 2.0, 0.0);
		h(width / 2.0, length);
		h(-width / 2.0, length);
		h(width / 8.0, length);
		h(width / 8.0, mlength);
		h(-width / 8.0, mlength);
		h(-width / 8.0, length);
		h(-width / 2.0, length);

		var thrusterOff = width * rrg(30, 70) * 0.05;
		// 2 Thrusters
		var thrusterOff = width * rrg(30, 70) * 0.005;
		t(-thrusterOff, 0.0, 12.0, 0.0);
		t(thrusterOff, 0.0, 12.0, 0.0);
		t(0.0, lengthd * 0.8 + length, 7.0, Math.PI);
		t(0.0, lengthd * 0.8 + length, 7.0, Math.PI / 2.0);
		t(0.0, lengthd * 0.8 + length, 7.0, -Math.PI / 2.0);
		t(thrusterOff, 0.0, 7.0, Math.PI / 2.0);
		t(-thrusterOff, 0.0, 7.0, -Math.PI / 2.0);

		// 2 Front Weapons
		var lPos = rrg(70, 100) * length * 0.01;
		var weaponOff = rrg(50, 80) * width * 0.005;

		weapons.push({x: weaponOff, y: lPos, dir: 0, size: 12.0, angle: Math.PI / 2.0, speed: 4.0, ftime: 0.3, ftimer: 0.0});
		weapons.push({x: -weaponOff, y: lPos, dir: 0, size: 12.0, angle: Math.PI / 2.0, speed: 4.0, ftime: 0.3, ftimer: 0.0});

		// 2 Side Weapons
		var lPos = rrg(30, 60) * length * 0.01;
		var weaponOff = rrg(50, 80) * width * 0.005;

		weapons.push({x: weaponOff, y: lPos, dir: -Math.PI / 2.0, size: 16.0, angle: Math.PI / 2.0, speed: 2.0, ftime: 0.5, ftimer: 0.0});
		weapons.push({x: -weaponOff, y: lPos, dir: Math.PI / 2.0, size: 16.0, angle: Math.PI / 2.0, speed: 2.0, ftime: 0.5, ftimer: 0.0});
	}
	else if(type == 2)
	{
		width = rrg(180, 260) * 0.5;
		length = width * rrg(200, 320) * 0.01;
		var centerWidth = width * rrg(40, 70) * 0.01;
		var waistLength = rrg(30, 60) * length * 0.01;
		// Waist-style hull
		
		h(width / 2.0, 0.0);
		h(centerWidth / 2.0, waistLength);
		h(width / 2.0, length);
		h(0.0, length * 1.1);
		h(-width / 2.0, length);
		h(-centerWidth / 2.0, waistLength);
		h(-width / 2.0, 0.0);

/*	ship.thrusters[0].t = xfw.a;
	ship.thrusters[1].t = xfw.a;
	ship.thrusters[2].t = xfw.b;
	if(ship.type == 2)
	{
		ship.thrusters[7].t = xfw.b;
	}
	ship.thrusters[3].t = Math.max(xside.a, xrot.a);
	ship.thrusters[4].t = Math.max(xside.b, xrot.b);
	ship.thrusters[5].t = Math.max(xside.a, xrot.b);
	ship.thrusters[6].t = Math.max(xside.b, xrot.a);
	*/

		// Forward
		t(width / 2.2, 0.0, 14.0, 0.0);
		t(-width / 2.2, 0.0, 14.0, 0.0);

		// Back 1
		t(-centerWidth * 0.5, waistLength, 12.0, Math.PI * 1.15);

		// Side
		t(centerWidth * 0.4, length * 0.74, 12.0, Math.PI / 2.0);
		t(-centerWidth * 0.4, length * 0.74, 12.0, -Math.PI / 2.0);
		t(centerWidth * 0.5, waistLength * 0.5, 12.0, Math.PI / 2.0);
		t(-centerWidth * 0.5, waistLength * 0.5, 12.0, -Math.PI / 2.0);

		// Back 2
		t(centerWidth * 0.5, waistLength, 12.0, -Math.PI * 1.15);


		// One huge center weapon
		weapons.push({x: 0.0, y: waistLength, dir: 0, size: 32.0, angle: Math.PI, speed: 2.0, ftime: 1.0, ftimer: 0.0});

		// Two side
		weapons.push({x: centerWidth / 2.2, y: waistLength * 1.8, dir: -Math.PI / 2.5, size: 20.0, angle: Math.PI / 2.0, speed: 2.0, ftime: 0.4, ftimer: 0.0});
		weapons.push({x: -centerWidth / 2.2, y: waistLength * 1.8, dir: Math.PI / 2.5, size: 20.0, angle: Math.PI / 2.0, speed: 2.0, ftime: 0.4, ftimer: 0.0});

		// Two front
		weapons.push({x: centerWidth / 1.8, y: length * 0.95, dir: 0, size: 12.0, angle: Math.PI / 2.5, speed: 4.0, ftime: 0.1, ftimer: 0.0});
		weapons.push({x: -centerWidth / 1.8, y: length * 0.95, dir: 0, size: 12.0, angle: Math.PI / 2.5, speed: 4.0, ftime: 0.1, ftimer: 0.0});
	}

	var levelScale = 1.0 + (level * 0.11);

	stats.maneouver = shipValues[type * 5 + 0] * levelScale;
	stats.speed = shipValues[type * 5 + 1] * levelScale;
	stats.armor = shipValues[type * 5 + 2] * levelScale;
	stats.fuel = shipValues[type * 5 + 3] * levelScale;
	stats.cargo = shipValues[type * 5 + 4] * levelScale;

	var health = stats.armor;

	for(var i = 0; i < weapons.length; i++)
	{
		weapons[i].size *= levelScale;
		weapons[i].ftime /= levelScale / 2.0;
	}
	
	var thrust = {fw: 0.0, side: 0.0, rot: 0.0};

	var scale = rrg(14, 25) * 0.01;
	var color = sideColor(side);

	return {level: level, health: health, destroyed:false, type: type, stats: stats, hull: hull, weapons: weapons, thrusters: thrusters, width: width, length: length, 
		x: 0.0, y: 0.0, rot: Math.PI, angspeed: 0.0, speed: {x: 0.0, y: 0.0}, thrust: thrust, acc: {x: 0.0, y: 0.0}, landed: false,
	scale: scale, firing: false, side: side, color: color, ai: {acc: rrg(5, 22), task: null, obj: null, beh: null, level: level, target: -1, targetTimer: 0.0}};
}

function drawShipLow(ship)
{
	// Draw hull
	ctx.fillStyle = ship.color;
	ctx.strokeStyle = 'white';
	ctx.lineWidth = 2.0;
	ctx.beginPath();

	ctx.moveTo(ship.hull[0].x, ship.hull[0].y);

	for(var i = 1; i < ship.hull.length; i++)
	{
		ctx.lineTo(ship.hull[i].x, ship.hull[i].y);
	}

	ctx.lineTo(ship.hull[0].x, ship.hull[0].y);

	ctx.fill();
	ctx.stroke();

	// Draw thrusters
	for(var i = 0; i < ship.thrusters.length; i++)
	{
		ctx.fillStyle = 'rgb(60, 60, 60)';
		ctx.strokeStyle = 'white';
		ctx.lineWidth = 2.0;

		var thruster = ship.thrusters[i];
		var tstuff = getThrusterStuff(thruster);

		ctx.beginPath();

		// Thruster triangle
		ctx.moveTo(thruster.x, thruster.y);
		ctx.lineTo(thruster.x + tstuff.nozzleX, thruster.y + tstuff.nozzleY);
		ctx.lineTo(thruster.x + tstuff.nozzle1X, thruster.y + tstuff.nozzle1Y);
		ctx.lineTo(thruster.x, thruster.y);

		ctx.fill();
		ctx.stroke();

		ctx.beginPath();

		ctx.arc(thruster.x, thruster.y, tstuff.thrusterSize, 0.0, Math.PI * 2.0);

		ctx.fill();
		ctx.stroke();
	}



	// Draw weapon attachments
	for(var i = 0; i < ship.weapons.length; i++)
	{
		ctx.lineWidth = 2.0;
		var weapon = ship.weapons[i];
		var weaponSize = weapon.size;

		ctx.beginPath();

		ctx.rect(weapon.x - weaponSize / 2.0, weapon.y - weaponSize / 2.0, weaponSize, weaponSize);
		ctx.fill();
		ctx.stroke();

		ctx.beginPath();

		ctx.lineWidth = 4.0;
		ctx.moveTo(weapon.x, weapon.y);
		var off = weaponSize * 1.5;
		ctx.lineTo(
		weapon.x + off * Math.cos(weapon.rdir + Math.PI / 2.0 - ship.rot), 
		weapon.y + off * Math.sin(weapon.rdir + Math.PI / 2.0 - ship.rot));
		ctx.stroke();
	}

}

function shipTransform(ship)
{
	ctx.translate(ship.x, ship.y);

	ctx.scale(ship.scale, ship.scale);

	ctx.rotate(ship.rot);

	ctx.translate(0.0, -ship.length / 2.0)
}

function drawShip(ship)
{
	shipTransform(ship);

	drawShipLow(ship);
	
	doCameraTransform();
}

function getThrusterStuff(thruster)
{

	var thrusterSize = thruster.size;

	var endPointX = Math.cos(thruster.dir - Math.PI / 2.0);
	var endPointY = Math.sin(thruster.dir - Math.PI / 2.0);

	var perpX = Math.cos(thruster.dir);
	var perpY = Math.sin(thruster.dir);

	var nozzleX = endPointX * thrusterSize * 2.0 + perpX * thrusterSize * 0.7;
	var nozzleY = endPointY * thrusterSize * 2.0 + perpY * thrusterSize * 0.7;
	var nozzle1X = endPointX * thrusterSize * 2.0 - perpX * thrusterSize * 0.7;
	var nozzle1Y = endPointY * thrusterSize * 2.0 - perpY * thrusterSize * 0.7;

	var thrust = (thruster.t + 0.00) * 8.0;

	return {nozzleX: nozzleX, nozzleY: nozzleY, 
		nozzle1X: nozzle1X, nozzle1Y: nozzle1Y, 
		thrust: thrust, thrusterSize: thrusterSize,
		endPointX: endPointX, endPointY: endPointY};

}

// TODO: Could be optimized into drawShip, but exhaust receive shadows
function drawShipExhaust(ship)
{
	shipTransform(ship);


	for(var i = 0; i < ship.thrusters.length; i++)
	{
		// Draw exhaust
		ctx.fillStyle = 'rgb(255, 255, 255)';
		ctx.strokeStyle = 'rgb(180, 180, 255)';
		ctx.lineWidth = 2.0;

		var thruster = ship.thrusters[i];
		var tstuff = getThrusterStuff(thruster);

		ctx.beginPath();
		ctx.lineTo(thruster.x + tstuff.nozzleX, thruster.y + tstuff.nozzleY);
		ctx.lineTo(thruster.x + tstuff.endPointX * (tstuff.thrust + 2.0) * tstuff.thrusterSize, 
		thruster.y + tstuff.thrusterSize * (tstuff.thrust + 2.0) * tstuff.endPointY);
		ctx.lineTo(thruster.x + tstuff.nozzle1X, thruster.y + tstuff.nozzle1Y);

		ctx.fill();
		ctx.stroke();
	}

	
	doCameraTransform();
}

function xvals(val)
{
	var a = 0.0;
	var b = 0.0;
	if(val >= 0.0)
	{
		a = val;
	}
	else 
	{
		b = -val;
	}

	return {a: a, b: b}
}

function setShipThrust(ship)
{
	var xrot = xvals(ship.thrust.rot);
	var xside = xvals(ship.thrust.side);
	var xfw = xvals(ship.thrust.fw);
	ship.thrusters[0].t = xfw.a;
	ship.thrusters[1].t = xfw.a;
	ship.thrusters[2].t = xfw.b;
	if(ship.type == 2)
	{
		ship.thrusters[7].t = xfw.b;
	}
	ship.thrusters[3].t = Math.max(xside.a, xrot.a);
	ship.thrusters[4].t = Math.max(xside.b, xrot.b);
	ship.thrusters[5].t = Math.max(xside.a, xrot.b);
	ship.thrusters[6].t = Math.max(xside.b, xrot.a);
}

// Aims all ship guns to given point
function aimShipGuns(ship, p)
{
	// Transform p to ship-relative coordinates

	var px = p.x - ship.x;
	var py = p.y - ship.y;

	for(var i = 0; i < ship.weapons.length; i++)
	{
		var weapon = ship.weapons[i];

		var srot = ship.rot;
	
		weapon.dir = sanitizeAngle(weapon.dir);
		var ang = srot + weapon.dir + Math.PI / 2.0;

		ang = sanitizeAngle(ang);


		var wepx = Math.cos(ang);
		var wepy = Math.sin(ang);

		var wdir = weapon.dir + srot;

		var angle0 = Math.atan2(py - wepy, px - wepx);
		var angle = Math.atan2(py, px) - Math.atan2(wepy, wepx);
		if (angle > Math.PI)        { angle -= 2 * Math.PI; }
		else if (angle <= -Math.PI) { angle += 2 * Math.PI; }

		if(Math.abs(angle) <= weapon.angle)
		{
			weapon.wdir = angle0 - Math.PI * 0.5;
			weapon.aim = true;
		}
		else
		{
			weapon.wdir = wdir;
			weapon.aim = false;
		}

		if(weapon.rdir == undefined)
		{
			weapon.rdir = wdir;
		}

		// TODO: Smooth gun aiming
		weapon.rdir = weapon.wdir;

		var slong = rotate(0.0, -ship.length / 2.0, ship.rot);
		var off = weapon.size * 1.5;
		var dx = Math.cos(weapon.rdir + Math.PI / 2.0);
		var dy = Math.sin(weapon.rdir + Math.PI / 2.0);

		var rpos = rotate(weapon.x * ship.scale, weapon.y * ship.scale, ship.rot);

		rpos.x += off * dx * ship.scale;
		rpos.y += off * dy * ship.scale;

		weapon.muzzle = {
			x: ship.x + rpos.x + ship.scale * slong.x, 
			y: ship.y + rpos.y + ship.scale * slong.y,
			dx: dx, dy: dy};
	}
}


function predictShip(ship)
{
	ship.predict = [];
	ship.collides = -1;
	
	ship.predict.push({x: ship.x, y: ship.y, sx: ship.speed.x, sy: ship.speed.y, time: time});


	var step = 0.5;
	var max = 500;

	if(ship.frame == 0)
	{
		step = 5.0;
		max = 15000;
		minDist = 1500.0;
	}
	else 
	{
		if(planets[ship.frame].center != 0)
		{
			step = 0.25;
		}
	}
	
	for(var i = 0; i < max / step; i++)
	{
		var point = {x: ship.predict[i].x, y: ship.predict[i].y};
		var speed = {x: ship.predict[i].sx, y: ship.predict[i].sy};
		var ntime = ship.predict[i].time;
		ntime += step;
		point.x += speed.x * step;
		point.y += speed.y * step;
		var acc = gravity(point, ntime);
		speed.x += acc.x * step;
		speed.y += acc.y * step;

		var coll = collidesWithPlanet(point, ntime);
		if(coll != null)
		{
			var pos0 = planetAtTime(coll.planet, ntime);
			ship.predict.push({x: coll.sx + pos0.x, y: coll.sy + pos0.y, sx: 0.0, sy: 0.0, time: ntime});
			ship.collides = coll.planet;
			break;
		}
		else
		{
			ship.predict.push({x: point.x, y: point.y, sx: speed.x, sy: speed.y, time: ntime});
		}

	}
}

function getSpeedVectorRelative(ship)
{
	var frame = planets[ship.frame];
	var frameVel = getPlanetSpeed(frame, time);
	

	return {x: ship.speed.x - frameVel.x, y: ship.speed.y - frameVel.y};
}

function getProgradeVector(ship)
{
	var vec = getSpeedVectorRelative(ship);
	return normalize(vec.x, vec.y);
}

function getAltitude(ship)
{
	var frame = planets[ship.frame];
	return distance(0, 0, ship.x - frame.x, ship.y - frame.y);
}

function getAltitudeGround(ship)
{
	var alt = getAltitude(ship);
	return alt - planets[ship.frame].radius;
}

function getProgradeAngle(ship)
{
	var vector = getProgradeVector(ship);
	return Math.atan2(vector.y, vector.x) - Math.PI / 2.0;
}

function getFrameSpeed(ship)
{
	var vec = getSpeedVectorRelative(ship);
	return distance(0, 0, vec.x, vec.y);
}

function simulateShip(ship, dt)
{
	if(rrg(0, 1000) >= (ship.health / ship.stats.armor) * 2000.0)
	{
		burn(ship.x + rrg(-10, 10), ship.y + rrg(-10, 10), ship.speed.x + rrg(-10, 10), ship.speed.y + rrg(-10, 10), rrg(4, 15), rrg(100, 200) * 0.005);
	}

	if(ship.destroyed)
	{
		ship.thrust.fw = 0.0;
		ship.thrust.side = 0.0;
		ship.thrust.rot = 0.0;
		ship.firing = false;

		ship.health -= dt;

		if(ship.health <= -50.0)
		{
			if(ship.side != 2)
			{
				explode(ship.x, ship.y, ship.speed.x, ship.speed.y, rrg(50, 200), 1.0, 1.0, true, false);
				return true;
			}
		}
	}
	else 
	{
		if(ship.health <= 0.0)
		{
			explode(ship.x, ship.y, ship.speed.x, ship.speed.y, rrg(100, 400), 0.7, 2.0, true, false, 1.0);
			ship.destroyed = true;
			ship.angspeed = rrg(-400, 400) * 0.01;
		}
	}

	setShipThrust(ship);

	if(ship.landed == true)
	{
		var pos = planetAtTime(ship.coll.planet, time);
		var landedPlanet = planets[ship.coll.planet];

		if(landedPlanet.type == 3)
		{
			return true;
		}

		var speed = orbitVelocity(landedPlanet.center, landedPlanet.mass, landedPlanet.orbitRadius, time, landedPlanet.orbitOffset);
		ship.x = pos.x + ship.coll.sx;
		ship.y = pos.y + ship.coll.sy;
		ship.speed.x = speed.x;
		ship.speed.y = speed.y;
		ship.angspeed = 0.0;

		var fwt = ship.thrust.fw;
		if(fwt > 0.0)
		{
			ship.landed = false;
			ship.speed.x = ship.coll.nx * 100.0 + speed.x;
			ship.speed.y = ship.coll.ny * 100.0 + speed.y;
			ship.x += ship.speed.x * dt;
			ship.y += ship.speed.y * dt;
		}

		if(landedPlanet.warTime != undefined && landedPlanet.warTime < 0.0)
		{
			if(ship.side == 0)
			{
				landedPlanet.humanForces.push(ship);
				return true;
			}
			else if(ship.side == 1)
			{
				landedPlanet.aiForces.push(ship);
				return true;
			}
		}
	}
	else 
	{
		// Acceleration 
		var point = {x: ship.x, y: ship.y};
		
		var coll = collidesWithPlanet(point, time);
		if(coll != null)
		{
			var planet = planets[coll.planet];
			var speed = orbitVelocity(planet.center, planet.mass, planet.orbitRadius, time, planet.orbitOffset);
			var speedRel = {x: ship.speed.x - speed.x, y: ship.speed.y - speed.y};
			var speedAbs = distance(0, 0, speedRel.x, speedRel.y);

			if(speedAbs >= 100.0)
			{
				ship.health -= (speedAbs - 100.0) * 0.8;
				explode(ship.x, ship.y, ship.speed.x, ship.speed.y, (speedAbs - 100.0) * 0.4, 0.8, 2.0, true, false)
			}

			ship.landed = true;
			ship.coll = coll;

		}

		var fwt = ship.thrust.fw;
		var sidet = ship.thrust.side;

		var front = {x: Math.cos(ship.rot + Math.PI / 2.0), y: Math.sin(ship.rot + Math.PI / 2.0)};
		var side = {x: Math.cos(ship.rot), y: Math.sin(ship.rot)};

		ship.speed.x += front.x * fwt * ship.stats.speed * dt * 5.0;
		ship.speed.y += front.y * fwt * ship.stats.speed * dt * 5.0;
		ship.speed.x += side.x * -sidet * ship.stats.speed * dt * 5.0;
		ship.speed.y += side.y * -sidet * ship.stats.speed * dt * 5.0;

		ship.angspeed += ship.stats.maneouver * dt * ship.thrust.rot;
		ship.x += ship.speed.x * dt;
		ship.y += ship.speed.y * dt;
		ship.rot += ship.angspeed * dt;

		var acc = gravity(point, -1.0);
		ship.speed.x += acc.x * dt;
		ship.speed.y += acc.y * dt;
		ship.acc = acc;


	}

	// Guns!
	
	for(var i = 0; i < ship.weapons.length; i++)
	{
		if(ship.firing && ship.weapons[i].aim == true && ship.weapons[i].ftimer <= 0.0)
		{
			var weapon = ship.weapons[i];

			var muzzle = weapon.muzzle;
			var muzzledir = normalize(muzzle.dx, muzzle.dy);


			var size = weapon.size / 8.0;
			var speed = 650.0 - (weapon.size / 32.0) * 350.0;


			explode(muzzle.x, muzzle.y, 
				ship.speed.x + muzzledir.x * 15.0, 
				ship.speed.y + muzzledir.y * 15.0, size * 4.0, 1.0, 0.5, true, true, 0.8);

			// Fire
			weapon.ftimer = weapon.ftime;

			shoot(muzzle.x, muzzle.y, muzzledir.x * speed + ship.speed.x, muzzledir.y * speed + ship.speed.y, ship.side, size, 10.0);
		}

		ship.weapons[i].ftimer -= dt;
	}

	return false;
}


function drawShipMap(ship)
{
	if(ship.side == 0)
	{
		ctx.fillStyle = 'rgb(128, 255, 128)';
	}
	else if(ship.side == 1)
	{
		ctx.fillStyle = 'rgb(255, 128, 128)';
	}
	else 
	{
		ctx.fillStyle = 'rgb(255, 255, 255)';
	}


	ctx.beginPath();
	ctx.arc(ship.x, ship.y, Math.min(5.0 / camera.zoom, 100.0), 0.0, Math.PI * 2.0);
	ctx.fill();
}


function freighterPrice()
{
	return !plHasFreighter * 4000.0;
}

function destroyerPrice()
{
	return !plHasDestroyer * 14000.0;
}

function repairPrice()
{
	return Math.floor((1.0 - (ships[0].health / ships[0].stats.armor)) * 500.0);
}

function upgradePrice()
{
	return ships[0].level * ships[0].level * 1000.0;
}

function orePrice()
{
	return 8.0 * plOre;
}

var holdingUpgrade = false;

function planetShop(key, release, ship, planet)
{
	if(release)
	{
		if(key == 'KeyU')
		{
			holdingUpgrade = false;
		}
	}

	if(!release)
	{

		if(planet.cities.length == 0)
		{
			if(key == 'KeyM')
			{
				if(plOre < ships[0].stats.cargo - 1 && mineTimer <= 0.0 && planet.ore > 0)
				{
					plOre++;
					planet.ore--;
					if(rrg(0, 1000) >= 980)
					{
						// Take some damage, play alarm
						showEvent("Accident while mining", 1.0);
						ships[0].health -= rrg(1, 5);
						zzfx(1,.1,50,.6,.5,.3,1,3.6,.03);
					}
					else 
					{
						zzfx(1,.1,rrg(220, 320), rrg(8, 17) * 0.01,.66,.3,0,3.6,.03);
					}
					mineTimer = rrg(15, 60) * 0.01;

				}
			}
		}
		else 
		{
			function newShipCopy(type)
			{
				var newShip = createShip(type, playerShipSeed, 2, ships[0].level);
				newShip.predict = new Array();
				newShip.frame = ships[0].frame;
				newShip.landed = true;
				newShip.coll = ships[0].coll;
				newShip.rot = ships[0].rot;
				return newShip;
			}

			function saveShip()
			{
				plLevels[ships[0].type] = ships[0].level;
				plHealths[ships[0].type] = ships[0].health;
			}

			var changeShipType = -1;

			if(key == 'KeyR')
			{
				if(plMoney >= repairPrice())
				{
					plMoney -= repairPrice();
					ships[0].health = ships[0].stats.armor;
					ships[0].destroyed = false;
				}
			}
			else if(key == 'KeyU')
			{
				if(!holdingUpgrade)
				{
					if(plMoney >= upgradePrice())
					{
						plMoney -= upgradePrice();
						ships[0].level++;
						var newShip = newShipCopy(ships[0].type);
						newShip.health = ships[0].health;
						ships[0] = newShip;

						zzfx(0.7,.1,15,.5,.13,0,0,30,.79); // ZzFX 71938
					}
					holdingUpgrade = true;
				}
			}
			else if(key == 'KeyS')
			{
				plMoney += orePrice();
				if(orePrice() != 0)
				{
					zzfx(1,.1,836,.2,.01,0,.3,1.3,.78); // ZzFX 18945
				}

				planet.humanAggro += plOre * 0.001 * 0.20;
				planet.humanAggro = Math.min(planet.humanAggro, 1.0);

				plOre = 0;
			}
			else if(key == 'Digit1')
			{
				if(ships[0].type != 0)
				{
					changeShipType = 0;
					zzfx(1,.1,2,.8,.42,0,0,67,.1); // ZzFX 30160
				}

			}
			else if(key == 'Digit2')
			{
				if(plMoney >= freighterPrice() && ships[0].type != 1)
				{
					changeShipType = 1;
					plMoney -= freighterPrice();
					plHasFreighter = true;
					zzfx(1,.1,5,.8,.42,-0.012,0,43,400); // ZzFX 30160

				}
			}
			else if(key == 'Digit3')
			{
				if(plMoney >= destroyerPrice() && ships[0].type != 2)
				{
					changeShipType = 2;
					plMoney -= destroyerPrice();
					plHasDestroyer = true;

					zzfx(1,.1,2,.8,.42,0,.6,33,.1); // ZzFX 30160
				}
			}

			if(changeShipType != -1)
			{
				saveShip();
				ships[0] = newShipCopy(changeShipType);

				if(plHealths[changeShipType] == 0)
				{
					plHealths[changeShipType] = ships[0].health;
				}

				ships[0].health = plHealths[changeShipType];
				ships[0].level = plLevels[changeShipType];
			}
		}

	}
}

function explosionSound(size, x, y, isShoot, volBoost = 0.6)
{
	var dist = distance(camera.x, camera.y, x, y);
	var factor = Math.min(Math.max(500.0 / (dist * 10.0), 0.005), 1.0);
	var l = 0.05 + size * 1.7;
	var freq = Math.min(100 / (Math.pow(size, 2.6) * 460.0), 500.0);


	if(!isShoot)
	{
		l = 0.1 + size * 0.67;
		freq = rrg(150 - size * 0.14, 280 - size * 0.14);
		
	}

	//freq /= Math.max(dist / 6200.0, 1.0);

	
	factor *= volBoost;

	zzfx(Math.min(factor * 4.0, 1.0),0,rrg(freq - size * 200.0, freq * 2.0), l,-5.0,0,8,0,.81);
	if(isShoot)
	{
		zzfx(Math.min(factor * size * 2.0, 1.0),0,rrg(freq, freq + 100.0), rrg(1, size * 0.1) * size * l * 2.0,0,0,8,0,0); // ZzFX 15338
	}
	 // ZzFX 15338
}

var notes = 
[
	0.0,	// Silence
	261.63,	//C4	1
	392.00,	//G4	2
	523.25,	//C5	3
	739.99,	//F#5	4
	932.33,	//A#5	5
	783.99,	//G5	6
	1046.50,//C6	7
	622.25,	//D#5	8
	415.30,	//G#4	9
	293.66,	//D4	10
	130.81,	//C3	11
	185.00,	//F#3	12 
	174.61,	//F3	13
	349.23,	//F4 	14
	369.99,	//F#4	15
	466.16,	//A#4	16
	196.00, //G3 	17
	220.00,	//A3	18
	246.94,	//B3 	19
	311.13,	//D#4	20
]

var spaceSong = 
[	
	// Lead 0 // Lead 1 // Lead 2	// Drum 3
	1 		, 4			, 5			, 1		,
	0		, 2			, 0			, 0		,
	0		, 3			, 0			, 2		,
	0		, 4			, 0			, 0		,
	0		, 5			, 0			, 1		,
	0		, 4			, 0			, 0		,
	0		, 3			, 0			, 2		,
	0		, 2			, 0			, 2		,
	1 		, 6			, 7			, 1		,
	0		, 2			, 0			, 0		,
	0		, 3			, 0			, 2		,
	0		, 6			, 0			, 0		,
	0		, 7			, 0			, 1		,
	0		, 6			, 0			, 0		,
	0		, 3			, 0			, 2		,
	0		, 2			, 0			, 2		,
]

var desertPlanetSong = 
[	
	// Lead 0 // Lead 1 // Lead 2	// Drum 3
	13		, 19		, 20		, 7		,
	13		, 19		, 0			, 0		,
	17		, 15		, 10		, 1		,
	0		, 0			, 0			, 0		,
	18		, 15		, 10		, 0		,
	18		, 0			, 10		, 0		,
	17		, 1			, 20		, 0		,
	0		, 0			, 0			, 0		,
]

var terraPlanetSong = 
[
	// Lead 0 // Lead 1 // Lead 2	// Drum 3
	16		, 4			, 0			, 0		,
	15		, 0			, 0			, 0		,
	20		, 5			, 0			, 0		,
	16		, 0			, 0			, 0		,
	15		, 0			, 0			, 0		,
	20		, 5			, 0			, 0		,
	19		, 4			, 0			, 0		,
	9		, 0			, 0			, 0		,
]

var rockyPlanetSong = 
[	
	// Lead 0 // Lead 1 // Lead 2	// Drum 3
	1 		, 0			, 0			, 1		,
	10		, 0			, 0			, 1		,
	15		, 0			, 0			, 7		,
	16		, 0			, 0			, 0		,
	1		, 0			, 0			, 1		,
	10		, 0			, 0			, 1		,
	15		, 0			, 0			, 7		,
	16		, 0			, 0			, 0		,
	15		, 0			, 0			, 1		,
	10		, 0			, 0			, 1		,
	1		, 0			, 0			, 7		,
	10		, 0			, 0			, 0		,
]

var combatSong = 
[
	0		, 11		, 0			, 11		,
	0		, 11		, 0			, 0		,
	0		, 0			, 0			, 7		,
	0		, 0			, 0			, 0		,
	0		, 0			, 0			, 11		,
	0		, 11		, 0			, 0		,
	0		, 12		, 0			, 7		,
	0		, 13		, 0			, 0		,
	0		, 11		, 1			, 11		,
	0		, 11		, 15		, 0		,
	0		, 0			, 14		, 7		,
	0		, 0			, 1			, 0		,
	0		, 0			, 0			, 11		,
	0		, 11		, 0			, 0		,
	0		, 12		, 1			, 7		,
	0		, 13		, 15		, 0		,
]

var musicTimer = 2.0;
var musicTempo = 1.0 / 4.0;
var musicPtr = 0;
var musicVol = 0.10;
var song = combatSong;
var selectSong = 0;
var muteMusic = false;

function music(dt)
{	
	if(!muteMusic)
	{

		musicVol = 0.07;
		if(selectSong == 0)
		{
			song = spaceSong;
		}
		else if(selectSong == 1)
		{
			song = rockyPlanetSong;
		}
		else if(selectSong == 2)
		{
			song = combatSong;
			musicVol = 0.11;
		}
		else if(selectSong == 3)
		{
			song = desertPlanetSong;
		}
		else if(selectSong == 4)
		{
			song = terraPlanetSong;
		}

		musicTimer -= dt;

		if(musicTimer <= 0.0)
		{
			musicPtr++;
			musicTimer = musicTempo;

			if(musicPtr * 4 > song.length - 1)
			{
				musicPtr = 0;
			}
			
			for(var i = 0; i < 4; i++)
			{
				var noise = i == 3 ? 3.0 : 0.0;
				var length = i == 3 ? musicTempo / 2.0 : musicTempo * 1.3;
				length = i == 0 ? musicTempo * 2.1 : length;
				var note = notes[song[musicPtr * 4 + i]];
				if(note != 0)
				{
					zzfx(musicVol,0,note,length,0,0,noise,0.0,0);
				}
			}		
		}
	}
}


function createStar(x, y, radius)
{
	return {x:x, y:y, radius:radius};
}
